<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>When2Solve — When2Meet Optimizer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,300&family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous">
<style>
/*═══════════════════════════════════════════════════════════════
  RESET & ROOT
═══════════════════════════════════════════════════════════════*/
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg-deep:#0a0e17;--bg-card:#111827;--bg-cell:#1a2235;--bg-hover:#243049;
  --border:#1e293b;--border-light:#334155;
  --text-primary:#e2e8f0;--text-secondary:#94a3b8;--text-muted:#64748b;
  --accent:#22d3ee;--accent-dim:rgba(34,211,238,0.15);
  --heat-0:#111827;--heat-1:#1e1a2e;--heat-2:#2d1f3d;--heat-3:#4c1d6e;
  --heat-4:#7c2d8e;--heat-5:#b83a6a;--heat-6:#e04842;--heat-7:#f59e0b;--heat-8:#fbbf24;
  --p0:#f472b6;--p1:#60a5fa;--p2:#a78bfa;--p3:#34d399;
  --p4:#fbbf24;--p5:#fb923c;--p6:#2dd4bf;--p7:#f87171;
}
html{font-size:16px;scroll-behavior:smooth}
body{font-family:'DM Sans',system-ui,sans-serif;background:var(--bg-deep);color:var(--text-primary);min-height:100vh;overflow-x:hidden}
body::before{content:'';position:fixed;inset:0;background:radial-gradient(ellipse at 25% 15%,rgba(124,45,142,0.07)0%,transparent 55%),radial-gradient(ellipse at 75% 85%,rgba(6,182,212,0.04)0%,transparent 55%);pointer-events:none;z-index:0}
::selection{background:rgba(34,211,238,0.3);color:#fff}

/*═══════════════════════════════════════════════════════════════
  LANDING PAGE
═══════════════════════════════════════════════════════════════*/
.landing{position:relative;z-index:1;min-height:100vh;display:flex;flex-direction:column;text-align:left;overflow:hidden}
.landing.hidden{display:none}
.landing-glow{position:fixed;inset:0;pointer-events:none;z-index:0;background:radial-gradient(600px circle at var(--mx,50%) var(--my,30%),rgba(34,211,238,0.06),transparent 60%);transition:background .3s ease}

/*── Hero ──*/
.hero{display:grid;grid-template-columns:1fr 1fr;gap:3rem;align-items:center;min-height:90vh;padding:4rem clamp(2rem,5vw,6rem);max-width:1200px;margin:0 auto;width:100%}
.hero-text{animation:fadeUp .8s ease-out}
.hero-eyebrow{display:flex;align-items:center;gap:.8rem;margin-bottom:1.5rem;flex-wrap:wrap}
.logo{font-family:'JetBrains Mono',monospace;font-size:.78rem;letter-spacing:.2em;text-transform:uppercase;color:var(--accent);font-weight:600}
.hero-badge{font-family:'JetBrains Mono',monospace;font-size:.62rem;letter-spacing:.04em;color:var(--text-muted);padding:.2rem .55rem;border:1px solid var(--border);border-radius:4px}
.hero-headline{font-size:clamp(2.6rem,5.5vw,4.2rem);font-weight:700;letter-spacing:-.04em;line-height:1.08;margin-bottom:1.5rem}
.hero-line{display:block}
.hero-line--dim{color:var(--text-muted)}
.hero-line--bright{color:var(--text-primary)}
.hero-line--bright em{font-style:normal;color:var(--accent);text-decoration:underline;text-decoration-color:rgba(34,211,238,0.3);text-underline-offset:5px;text-decoration-thickness:2px}
.hero-sub{font-size:1.05rem;color:var(--text-secondary);line-height:1.65;max-width:460px;margin-bottom:2rem;font-weight:300}
.hero-actions{display:flex;gap:1rem;align-items:center;flex-wrap:wrap}
.cta-primary{display:inline-flex;align-items:center;gap:.5rem;padding:.85rem 1.8rem;background:var(--accent);color:var(--bg-deep);font-family:'DM Sans',sans-serif;font-size:.95rem;font-weight:600;border:none;border-radius:10px;cursor:pointer;transition:all .2s;box-shadow:0 0 30px rgba(34,211,238,0.2),0 4px 12px rgba(0,0,0,0.3)}
.cta-primary:hover{transform:translateY(-2px);box-shadow:0 0 45px rgba(34,211,238,0.35),0 8px 20px rgba(0,0,0,0.4)}
.cta-primary:active{transform:translateY(0)}
.cta-secondary{display:inline-flex;align-items:center;gap:.4rem;font-size:.88rem;color:var(--text-muted);text-decoration:none;transition:color .2s}
.cta-secondary:hover{color:var(--text-secondary)}
.cta-secondary i{font-size:.7rem}
.cta-secondary-btn{display:inline-flex;align-items:center;gap:.5rem;padding:.6rem 1.2rem;background:transparent;border:1px solid var(--border-light);border-radius:8px;color:var(--text-secondary);font-size:.88rem;font-weight:500;cursor:pointer;transition:all .2s;font-family:'DM Sans',sans-serif}
.cta-secondary-btn:hover{border-color:var(--text-muted);color:var(--text-primary);background:rgba(255,255,255,0.02)}

/*── URL Input ──*/
.url-input-group{margin-bottom:1.5rem;max-width:460px}
.url-input-wrap{display:flex;align-items:center;background:var(--bg-card);border:1.5px solid var(--border);border-radius:10px;padding:.15rem .15rem .15rem .8rem;transition:border-color .2s,box-shadow .2s}
.url-input-wrap:focus-within{border-color:var(--accent);box-shadow:0 0 20px rgba(34,211,238,0.1)}
.url-input-icon{color:var(--text-muted);font-size:.8rem;flex-shrink:0}
.url-input{flex:1;background:none;border:none;outline:none;color:var(--text-primary);font-family:'JetBrains Mono',monospace;font-size:.82rem;padding:.6rem .6rem;min-width:0}
.url-input::placeholder{color:var(--text-muted);opacity:.6}
.url-go{flex-shrink:0;width:36px;height:36px;border-radius:8px;border:none;background:var(--accent);color:var(--bg-deep);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:.85rem;transition:all .15s}
.url-go:hover{background:#06b6d4;transform:scale(1.05)}
.url-go:disabled{opacity:.4;cursor:not-allowed;transform:none}
.url-go.loading{animation:pulse 1s ease-in-out infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
.url-status{font-size:.75rem;margin-top:.4rem;min-height:1.1em;font-family:'JetBrains Mono',monospace}
.url-status.error{color:#ef4444}
.url-status.loading{color:var(--text-muted)}
.url-status.success{color:var(--accent)}

/*── W2M Overlay ──*/
.w2m-overlay{position:absolute;inset:0;z-index:10;background:#f0f0f0;border-radius:0 0 12px 12px;overflow:hidden;animation:w2mFade .5s ease-out 2s forwards;display:flex;flex-direction:column}
.w2m-title{background:#339900;color:#fff;font-size:.7rem;font-weight:700;padding:.35rem .7rem;font-family:Arial,sans-serif;letter-spacing:.02em;flex-shrink:0}
.w2m-grid{display:grid;grid-template-columns:2.5rem repeat(5,1fr);grid-auto-rows:1fr;gap:0;padding:.3rem .4rem;flex:1;min-height:0}
.w2m-corner{background:transparent}
.w2m-day{font-size:.48rem;color:#333;font-family:Arial,sans-serif;text-align:center;font-weight:700;padding-bottom:2px}
.w2m-tl{font-size:.4rem;color:#555;font-family:Arial,sans-serif;text-align:right;padding-right:4px;display:flex;align-items:center;justify-content:flex-end;border-top:1px solid #bbb}
.w2m-ts{background:transparent}
.w2m-cell{border:1px solid #ccc;border-radius:0;min-height:0}
.w2m-0{background:#fff}.w2m-1{background:#d5ecc8}.w2m-2{background:#aad48e}.w2m-3{background:#91c86e}.w2m-4{background:#77bb55}
.w2m-scan{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden}
.w2m-scan::after{content:'';position:absolute;top:0;width:3px;height:100%;background:linear-gradient(90deg,transparent,rgba(34,211,238,0.6),transparent);box-shadow:0 0 12px rgba(34,211,238,0.4);animation:w2mScan 1.5s ease-in-out .3s forwards}
@keyframes w2mFade{to{opacity:0;transform:translateY(8px);pointer-events:none}}
@keyframes w2mScan{from{left:-3px}to{left:100%}}

/*── Hero Visualization ──*/
.hero-viz{position:relative;animation:fadeUp .8s ease-out .3s both}
.viz-window{background:var(--bg-card);border:1px solid var(--border);border-radius:12px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.4),0 0 40px rgba(34,211,238,0.04)}
.viz-topbar{display:flex;align-items:center;gap:6px;padding:.55rem .8rem;background:rgba(0,0,0,0.3);border-bottom:1px solid var(--border)}
.viz-dot{width:10px;height:10px;border-radius:50%}
.viz-dot--r{background:#ef4444}.viz-dot--y{background:#fbbf24}.viz-dot--g{background:#34d399}
.viz-title{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted);margin-left:auto;letter-spacing:.05em}
.viz-body{padding:1rem;position:relative}
/*-- Mini team chips --*/
.viz-team{display:flex;flex-wrap:wrap;gap:4px;margin-bottom:.7rem}
.viz-team-chip{font-family:'JetBrains Mono',monospace;font-size:.58rem;padding:3px 8px;border-radius:12px;border:1px solid var(--border);color:var(--text-secondary);display:inline-flex;align-items:center;gap:4px;opacity:0;animation:chipPop .25s ease-out forwards}
.viz-team-chip::before{content:'';width:7px;height:7px;border-radius:50%;background:var(--chip-color);flex-shrink:0}
@keyframes chipPop{from{opacity:0;transform:scale(.3)}to{opacity:1;transform:scale(1)}}
/*-- Recommendation card --*/
.viz-rec{background:rgba(34,211,238,0.04);border:1px solid rgba(34,211,238,0.25);border-radius:10px;padding:.7rem .85rem;margin-bottom:.6rem;opacity:0;animation:slideUp .5s ease-out 3s both}
@keyframes slideUp{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
.viz-rec-label{font-family:'JetBrains Mono',monospace;font-size:.55rem;color:var(--accent);text-transform:uppercase;letter-spacing:.1em;margin-bottom:.2rem;font-weight:600}
.viz-rec-main{display:flex;align-items:baseline;gap:.45rem;margin-bottom:.35rem}
.viz-rec-day{font-size:1rem;font-weight:700;color:var(--text-primary)}
.viz-rec-time{font-family:'JetBrains Mono',monospace;font-size:.72rem;color:var(--text-secondary)}
.viz-rec-dots{display:flex;gap:4px;margin-bottom:.25rem}
.viz-rec-dot{width:10px;height:10px;border-radius:50%;opacity:0;animation:dotPop .3s ease-out forwards}
@keyframes dotPop{from{opacity:0;transform:scale(0)}to{opacity:1;transform:scale(1)}}
.viz-rec-count{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-secondary);opacity:0;animation:fadeUp .3s ease-out 3.6s both}
.viz-rec-hl{color:var(--accent);font-weight:500}
/*-- Alternative card --*/
.viz-alt{background:var(--bg-cell);border:1px solid var(--border);border-radius:8px;padding:.5rem .7rem;margin-bottom:.6rem;opacity:0;animation:slideUp .4s ease-out 4.3s both}
.viz-alt-day{font-size:.78rem;font-weight:600;color:var(--text-primary)}
.viz-alt-time{font-family:'JetBrains Mono',monospace;font-size:.62rem;color:var(--text-muted);margin-bottom:.25rem}
.viz-alt-dots{display:flex;gap:3px;margin-bottom:.2rem}
.viz-alt-dot{width:8px;height:8px;border-radius:50%;opacity:0;animation:dotPop .25s ease-out forwards}
.viz-alt-dot.absent{background:transparent!important;border:1px solid var(--border-light)}
/*-- Mini scenario explorer --*/
.viz-scenario{border:1.5px dashed rgba(34,211,238,0.25);border-radius:8px;padding:.45rem .65rem;margin-bottom:.6rem;opacity:0;animation:slideUp .4s ease-out 3.5s both}
.viz-scenario-header{display:flex;align-items:center;gap:.4rem;font-size:.62rem;color:var(--text-secondary);line-height:1.4;margin-bottom:.3rem}
.viz-scenario-chev{font-size:.5rem;color:var(--text-muted);transform:rotate(90deg)}
.viz-scenario-badge{font-family:'JetBrains Mono',monospace;font-size:.45rem;letter-spacing:.08em;text-transform:uppercase;color:rgba(34,211,238,0.7);background:rgba(34,211,238,0.08);padding:1px 4px;border-radius:2px}
.viz-scenario-card{padding:.3rem .5rem;border-left:1.5px dashed rgba(34,211,238,0.3);border-radius:0 5px 5px 0;background:rgba(34,211,238,0.03);font-size:.62rem;color:var(--text-secondary);line-height:1.45;display:flex;align-items:flex-start;gap:.35rem;margin-top:3px;opacity:0;animation:fadeUp .35s ease-out 3.8s both}
.viz-scenario-card-2{animation-delay:3.95s}
.viz-scenario-card-3{animation-delay:4.1s}
.viz-scenario-card strong{color:var(--text-primary);font-weight:600}
.viz-scenario-icon{flex-shrink:0;color:var(--text-muted);font-size:.6rem;width:1em;text-align:center;margin-top:1px}
/*-- Mini insights --*/
.viz-insights{opacity:0;animation:slideUp .5s ease-out 5s both}
.viz-insight{display:flex;align-items:flex-start;gap:.5rem;padding:.3rem 0;font-size:.7rem;color:var(--text-secondary);line-height:1.4;opacity:0}
.viz-insight:first-child{animation:fadeUp .4s ease-out 5.2s both}
.viz-insight:last-child{animation:fadeUp .4s ease-out 5.5s both}
.viz-insight-icon{flex-shrink:0;color:var(--text-muted);font-size:.7rem;width:1em;text-align:center;margin-top:1px}
.viz-insight strong{color:var(--text-primary);font-weight:600}
.viz-alt-count{font-family:'JetBrains Mono',monospace;font-size:.6rem;color:var(--text-muted)}


/*── Heat Divider ──*/
.heat-divider{display:flex;height:3px;width:100%}
.heat-bar{flex:1}

/*── Setup Section ──*/
/*── Landing Footer ──*/
.landing-footer{text-align:center;font-size:.82rem;color:var(--text-muted);padding:2rem;border-top:1px solid var(--border)}
.landing-footer a{color:var(--accent);text-decoration:none}
.landing-footer .by{color:var(--text-secondary)}
.topbar-by{font-size:.65rem;color:var(--text-muted);font-weight:300;letter-spacing:.02em;opacity:.7}

/*── Landing Responsive ──*/
@media(max-width:768px){
  .hero{grid-template-columns:1fr;min-height:auto;padding:3rem 1.5rem 2rem;gap:2rem}
  .hero-text{text-align:center}
  .hero-sub{margin:0 auto 2rem}
  .hero-actions{justify-content:center}
  .hero-headline{font-size:clamp(2rem,8vw,3rem)}
}

/*═══════════════════════════════════════════════════════════════
  SOLVER VIEW
═══════════════════════════════════════════════════════════════*/
.solver{display:none;position:relative;z-index:1;max-width:1100px;margin:0 auto;padding:1.2rem}
.solver.active{display:block}
.landing.hidden{display:none}

.topbar{display:flex;align-items:center;justify-content:space-between;margin-bottom:1rem;flex-wrap:wrap;gap:.7rem;animation:fadeDown .5s ease-out;padding:.7rem 1rem;background:var(--bg-card);border:1px solid var(--border);border-radius:12px}
.topbar-left{display:flex;align-items:center;gap:.8rem}
.topbar-brand{font-family:'JetBrains Mono',monospace;font-size:.85rem;font-weight:600;color:var(--accent);letter-spacing:.06em;cursor:pointer;transition:opacity .2s}
.topbar-brand:hover{opacity:.7}
.topbar-event{font-size:.85rem;color:var(--text-muted);max-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.topbar-center{display:flex;align-items:center;gap:1rem;flex-wrap:wrap}
.topbar-right{display:flex;align-items:center;gap:.6rem}
.topbar-badge{font-family:'JetBrains Mono',monospace;font-size:.72rem;padding:.3rem .65rem;border-radius:6px;background:rgba(34,211,238,0.08);border:1px solid rgba(34,211,238,0.15);color:var(--accent);letter-spacing:.04em}
.ctrl-label{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:.1em;white-space:nowrap}
.seg-group{display:flex;align-items:center;gap:.45rem}
.seg-btns{display:flex;background:var(--bg-deep);border-radius:8px;padding:3px;border:1px solid var(--border);overflow:hidden}
.seg-btn{font-family:'JetBrains Mono',monospace;font-size:.75rem;padding:.35rem .65rem;color:var(--text-muted);cursor:pointer;transition:all .2s;white-space:nowrap;user-select:none;border-radius:5px;text-align:center}
.seg-btn:hover{color:var(--text-secondary)}
.seg-btn.active{background:var(--bg-hover);color:var(--text-primary)}
@media(max-width:720px){.topbar{flex-direction:column;align-items:stretch;gap:.5rem}.topbar-center{justify-content:center}.topbar-right{justify-content:flex-end}}

.blocked-bar{display:flex;align-items:center;gap:.6rem;padding:.5rem .8rem;margin-bottom:.5rem;flex-wrap:wrap}
.blocked-list{display:flex;flex-wrap:wrap;gap:4px;align-items:center}
.blocked-chip{font-family:'JetBrains Mono',monospace;font-size:.7rem;padding:3px 8px;border-radius:5px;background:rgba(239,68,68,0.1);color:#ef4444;border:1px solid rgba(239,68,68,0.2);display:flex;align-items:center;gap:4px;cursor:pointer;transition:all .2s}
.blocked-chip:hover{background:rgba(239,68,68,0.2)}
.blocked-chip .x{font-size:.8rem;line-height:1}

/*── Team bar ──*/
.team-bar{display:flex;flex-wrap:wrap;align-items:center;gap:.5rem;padding:.75rem 1rem;background:var(--bg-card);border:1px solid var(--border);border-radius:12px;margin-bottom:1rem;animation:fadeUp .5s ease-out .2s both}
.team-label{font-family:'JetBrains Mono',monospace;font-size:.7rem;text-transform:uppercase;letter-spacing:.1em;color:var(--text-muted);margin-right:.3rem}
.team-chip{display:inline-flex;align-items:center;gap:6px;padding:5px 12px;border-radius:20px;background:rgba(255,255,255,0.02);border:1px solid var(--border);font-size:.82rem;cursor:pointer;transition:all .2s;user-select:none}
.team-chip:hover{border-color:var(--border-light);background:var(--bg-hover)}
.team-chip.required{border-color:rgba(34,211,238,0.3);background:rgba(34,211,238,0.06)}
.chip-dot{width:9px;height:9px;border-radius:50%;flex-shrink:0}
.chip-hours{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted)}
.chip-req{font-family:'JetBrains Mono',monospace;font-size:.52rem;text-transform:uppercase;letter-spacing:.06em;color:var(--accent);background:var(--accent-dim);padding:2px 5px;border-radius:3px}
.team-stats{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted);margin-left:auto}

/*── Decision cards ──*/
.decisions{margin-bottom:1.2rem}
.section-head{font-family:'JetBrains Mono',monospace;font-size:.72rem;text-transform:uppercase;letter-spacing:.12em;color:var(--text-muted);margin-bottom:.8rem;margin-top:1.2rem;display:flex;align-items:center;gap:.6rem}
.section-head::after{content:'';flex:1;height:1px;background:var(--border)}

/* Hero recommendation */
.hero-card{background:var(--bg-card);border:1px solid rgba(34,211,238,0.3);border-radius:14px;padding:1.6rem;margin-bottom:1rem;position:relative;animation:fadeUp .5s ease-out both;box-shadow:0 0 30px rgba(34,211,238,0.06)}
.hero-label{font-family:'JetBrains Mono',monospace;font-size:.65rem;text-transform:uppercase;letter-spacing:.12em;color:var(--accent);margin-bottom:.5rem;font-weight:600}
.hero-main{display:flex;align-items:baseline;gap:.6rem;margin-bottom:.2rem;flex-wrap:wrap}
.hero-day{font-size:1.5rem;font-weight:700;color:var(--text-primary)}
.hero-time{font-family:'JetBrains Mono',monospace;font-size:1.05rem;color:var(--text-secondary)}
.hero-dots{display:flex;gap:6px;margin:.6rem 0 .4rem;flex-wrap:wrap}
.hero-dots .att-dot{width:14px;height:14px}
.hero-count{font-family:'JetBrains Mono',monospace;font-size:.88rem;color:var(--text-secondary);margin-bottom:.15rem}
.hero-missing{font-size:.82rem;color:var(--text-muted);font-style:italic;line-height:1.4}
.hero-missing.card-all{color:var(--accent);font-style:normal;font-weight:500}
.hero-dismiss{position:absolute;top:1rem;right:1rem;background:none;border:1px solid var(--border);border-radius:6px;color:var(--text-muted);font-size:.72rem;padding:.3rem .8rem;cursor:pointer;transition:all .2s;font-family:'DM Sans',sans-serif}
.hero-dismiss:hover{color:#ef4444;border-color:rgba(239,68,68,0.3);background:rgba(239,68,68,0.04)}

/* Runner-up cards */
.runners-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(210px,1fr));gap:.7rem;margin-bottom:.8rem}
.option-card{background:var(--bg-card);border:1px solid var(--border);border-radius:12px;padding:1.1rem;position:relative;transition:all .3s;animation:fadeUp .5s ease-out both}
.option-card:hover{border-color:var(--border-light);transform:translateY(-2px)}
.card-day{font-size:1.1rem;font-weight:600;color:var(--text-primary);margin-bottom:.1rem}
.card-time{font-family:'JetBrains Mono',monospace;font-size:.78rem;color:var(--text-secondary);margin-bottom:.5rem}
.att-dots{display:flex;gap:5px;margin-bottom:.4rem;flex-wrap:wrap}
.att-dot{width:12px;height:12px;border-radius:50%;transition:all .2s}
.att-dot.absent{background:transparent!important;opacity:.3}
.card-count{font-family:'JetBrains Mono',monospace;font-size:.72rem;color:var(--text-secondary);margin-bottom:.2rem}
.card-missing{font-size:.72rem;color:var(--text-muted);font-style:italic;margin-bottom:.5rem;min-height:1em;line-height:1.4}
.card-missing.card-all{color:var(--accent);font-style:normal;font-weight:500}
.card-dismiss{background:none;border:1px solid var(--border);border-radius:6px;color:var(--text-muted);font-size:.68rem;padding:.3rem .6rem;cursor:pointer;transition:all .2s;width:100%;font-family:'DM Sans',sans-serif}
.card-dismiss:hover{color:#ef4444;border-color:rgba(239,68,68,0.3);background:rgba(239,68,68,0.04)}

/* Show more toggle */
.show-more{font-family:'JetBrains Mono',monospace;font-size:.72rem;color:var(--text-muted);cursor:pointer;padding:.4rem 0;transition:color .2s;user-select:none;margin-bottom:.8rem}
.show-more:hover{color:var(--text-secondary)}
.more-options{display:none;margin-bottom:.8rem}
.more-options.open{display:block}
.more-options.open.more-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(210px,1fr));gap:.7rem}

/*── Plan cards ──*/
.plan-card{background:var(--bg-card);border:1px solid var(--border);border-radius:12px;padding:1.4rem;position:relative;margin-bottom:.8rem;animation:fadeUp .5s ease-out both}
.plan-card.best{border-color:rgba(34,211,238,0.3);box-shadow:0 0 24px rgba(34,211,238,0.06)}
.plan-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:.9rem}
.plan-label{font-family:'JetBrains Mono',monospace;font-size:.72rem;text-transform:uppercase;letter-spacing:.08em;color:var(--accent);font-weight:600}
.plan-coverage-badge{font-family:'JetBrains Mono',monospace;font-size:.72rem;padding:.25rem .7rem;border-radius:5px;background:rgba(34,211,238,0.08);color:var(--accent);border:1px solid rgba(34,211,238,0.15)}
.plan-meetings{display:grid;grid-template-columns:1fr auto 1fr;gap:.6rem;align-items:start;margin-bottom:.7rem}
.plan-meeting{background:rgba(255,255,255,0.015);border:1px solid var(--border);border-radius:8px;padding:.85rem}
.plan-connector{font-size:.85rem;color:var(--text-muted);font-weight:700;display:flex;align-items:center;justify-content:center;padding-top:1.4rem}
.plan-breakdown{font-size:.75rem;color:var(--text-muted);line-height:1.6;margin-bottom:.4rem}
.plan-breakdown span{font-weight:500;color:var(--text-secondary)}
.plan-dismiss{position:absolute;top:.9rem;right:.9rem;background:none;border:none;color:var(--text-muted);font-size:1.1rem;cursor:pointer;padding:4px 8px;border-radius:4px;transition:all .2s;line-height:1}
.plan-dismiss:hover{color:#ef4444;background:rgba(239,68,68,0.06)}
@media(max-width:580px){.plan-meetings{grid-template-columns:1fr}.plan-connector{padding:0;font-size:.75rem}}

/*── Insights ──*/
.insights-panel{background:var(--bg-card);border:1px solid var(--border);border-radius:12px;padding:1rem 1.2rem;margin-bottom:1rem}
.insight-item{display:flex;align-items:center;gap:.65rem;padding:.45rem 0;font-size:.85rem;color:var(--text-secondary);line-height:1.5;border-bottom:1px solid rgba(255,255,255,0.03)}
.insight-item:last-child{border-bottom:none}
.insight-icon{flex-shrink:0;width:1.1em;display:inline-flex;align-items:center;justify-content:center;color:var(--text-muted);font-size:.9rem}
.insight-item strong{color:var(--text-primary);font-weight:600}
.insight-item .hl{color:#22d3ee}
.insight-item .warn{color:#fbbf24}
.insight-item .soft{color:var(--text-muted);font-size:.75rem}

/*── Scenario Explorer ──*/
.scenario-panel{background:var(--bg-card);border:2px dashed rgba(34,211,238,0.25);border-radius:12px;padding:1rem 1.2rem;margin-bottom:1rem;animation:fadeUp .4s ease both}
.scenario-summary{display:flex;align-items:center;gap:.6rem;cursor:pointer;user-select:none;padding:.3rem 0;font-size:.85rem;color:var(--text-secondary);transition:color .2s}
.scenario-summary:hover{color:var(--text-primary)}
.scenario-summary .chev{transition:transform .25s;font-size:.65rem;color:var(--text-muted)}
.scenario-summary .chev.open{transform:rotate(90deg)}
.scenario-body{display:none;padding-top:.6rem}
.scenario-body.open{display:block}
.scenario-card{padding:.6rem .8rem;margin:.45rem 0;border-left:2px dashed rgba(34,211,238,0.3);border-radius:0 8px 8px 0;background:rgba(34,211,238,0.03);font-size:.82rem;color:var(--text-secondary);line-height:1.55}
.scenario-card strong{color:var(--text-primary);font-weight:600}
.scenario-card .hl{color:#22d3ee}
.scenario-card .warn{color:#fbbf24}
.scenario-badge{display:inline-block;font-family:'JetBrains Mono',monospace;font-size:.55rem;letter-spacing:.08em;text-transform:uppercase;color:rgba(34,211,238,0.7);background:rgba(34,211,238,0.08);padding:1px 6px;border-radius:3px;margin-right:.5rem;vertical-align:middle}
.scenario-icon{flex-shrink:0;width:1.2em;display:inline-flex;align-items:center;justify-content:center;color:var(--text-muted);font-size:.85rem;margin-right:.4rem}
.scenario-dots .att-dot{opacity:.55;filter:saturate(0.5)}

/*── Heatmap (collapsible) ──*/
.heatmap-toggle{display:flex;align-items:center;gap:.5rem;padding:.6rem 0;font-family:'JetBrains Mono',monospace;font-size:.78rem;color:var(--text-muted);cursor:pointer;transition:color .2s;user-select:none}
.heatmap-toggle:hover{color:var(--text-secondary)}
.heatmap-section{overflow:hidden;transition:all .3s}
.heatmap-section.collapsed{display:none}
.heatmap-inner{display:grid;grid-template-columns:1fr 220px;gap:1rem;align-items:start}
@media(max-width:900px){.heatmap-inner{grid-template-columns:1fr}}
.heatmap-panel{background:var(--bg-card);border:1px solid var(--border);border-radius:14px;padding:1.2rem;overflow-x:auto}
.heatmap-wrapper{min-width:640px;position:relative}
.heatmap-grid{display:grid;gap:0;position:relative}
.day-header{text-align:center;padding:.5rem .2rem;font-weight:600;font-size:.88rem;letter-spacing:.03em;color:var(--text-secondary);border-bottom:1px solid var(--border)}
.time-header{border-bottom:1px solid var(--border);display:flex;align-items:flex-end;justify-content:center;padding-bottom:.4rem;font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted);letter-spacing:.08em;text-transform:uppercase}
.time-label{font-family:'JetBrains Mono',monospace;font-size:.7rem;color:var(--text-muted);display:flex;align-items:center;justify-content:flex-end;padding-right:6px;height:22px;user-select:none}
.time-label.hour{color:var(--text-secondary);font-weight:500}
.cell{height:22px;border:1px solid rgba(30,41,59,0.4);cursor:pointer;transition:all .12s;position:relative}
.cell:hover{transform:scaleY(1.4);z-index:5;border-color:rgba(255,255,255,0.15);box-shadow:0 0 10px rgba(255,255,255,0.04)}
.cell.h0{background:var(--heat-0)}.cell.h1{background:var(--heat-1)}.cell.h2{background:var(--heat-2)}
.cell.h3{background:var(--heat-3)}.cell.h4{background:var(--heat-4)}.cell.h5{background:var(--heat-5)}
.cell.h6{background:var(--heat-6)}.cell.h7{background:var(--heat-7)}.cell.h8{background:var(--heat-8)}
.cell.h9{background:#fcd34d}.cell.h10{background:#fde68a}
.cell.person-on{box-shadow:inset 0 0 8px rgba(255,255,255,0.15)}
.cell.person-off{background:var(--heat-0)!important;opacity:.35}
.cell.blocked::before{content:'';position:absolute;inset:0;background:repeating-linear-gradient(-45deg,transparent,transparent 3px,rgba(239,68,68,0.15) 3px,rgba(239,68,68,0.15) 4px);pointer-events:none;z-index:1}

.sol-outline{position:absolute;border:2px solid var(--accent);border-radius:4px;pointer-events:none;z-index:10;animation:solPulse 2.5s ease-in-out infinite;box-shadow:0 0 18px rgba(34,211,238,0.15),inset 0 0 18px rgba(34,211,238,0.04)}
.sol-outline .sol-tag{position:absolute;top:-22px;left:50%;transform:translateX(-50%);font-family:'JetBrains Mono',monospace;font-size:.68rem;font-weight:600;color:var(--accent);white-space:nowrap;letter-spacing:.04em;text-shadow:0 0 10px rgba(34,211,238,0.4)}
@keyframes solPulse{0%,100%{border-color:rgba(34,211,238,0.75);box-shadow:0 0 18px rgba(34,211,238,0.15),inset 0 0 18px rgba(34,211,238,0.04)}50%{border-color:rgba(34,211,238,0.35);box-shadow:0 0 32px rgba(34,211,238,0.3),inset 0 0 22px rgba(34,211,238,0.08)}}

.heat-legend{display:flex;align-items:center;justify-content:center;gap:1px;margin-top:.8rem;padding-top:.8rem;border-top:1px solid var(--border)}
.heat-legend span{font-family:'JetBrains Mono',monospace;font-size:.68rem;color:var(--text-muted);margin:0 6px}
.hswatch{width:22px;height:12px;border-radius:2px}

.panel{background:var(--bg-card);border:1px solid var(--border);border-radius:14px;padding:1rem}
.panel-title{font-family:'JetBrains Mono',monospace;font-size:.72rem;text-transform:uppercase;letter-spacing:.12em;color:var(--text-muted);margin-bottom:.8rem}
.person-row{display:flex;align-items:center;gap:8px;padding:6px 8px;margin:2px 0;border-radius:7px;cursor:pointer;transition:all .2s;user-select:none;position:relative}
.person-row:hover{background:var(--bg-hover)}
.person-row.active{background:var(--bg-hover)}
.person-row.required::after{content:'REQ';position:absolute;right:7px;top:50%;transform:translateY(-50%);font-family:'JetBrains Mono',monospace;font-size:.55rem;color:var(--accent);letter-spacing:.06em;background:var(--accent-dim);padding:2px 6px;border-radius:3px}
.pdot{width:10px;height:10px;border-radius:50%;flex-shrink:0;transition:transform .2s,box-shadow .2s}
.person-row.active .pdot{transform:scale(1.5);box-shadow:0 0 8px currentColor}
.pname{font-size:.9rem;font-weight:500;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.phours{font-family:'JetBrains Mono',monospace;font-size:.75rem;color:var(--text-muted)}
.pbar-track{position:absolute;bottom:0;left:0;right:0;height:2px;background:rgba(255,255,255,0.03);border-radius:1px;overflow:hidden}
.pbar-fill{height:100%;border-radius:1px;transform-origin:left;animation:barIn .8s ease-out forwards}
@keyframes barIn{from{transform:scaleX(0)}to{transform:scaleX(1)}}
.clear-btn{display:none;margin-top:.5rem;padding:.4rem;background:rgba(239,68,68,0.06);border:1px solid rgba(239,68,68,0.15);border-radius:6px;color:#ef4444;font-size:.78rem;font-weight:500;cursor:pointer;text-align:center;transition:all .2s;font-family:'DM Sans',sans-serif}
.clear-btn:hover{background:rgba(239,68,68,0.12)}
.clear-btn.show{display:block}

.dismissed-info{text-align:center;margin-top:.7rem;font-size:.75rem;color:var(--text-muted)}
.dismissed-info a{color:var(--accent);cursor:pointer;text-decoration:none}
.dismissed-info a:hover{text-decoration:underline}

/*── Tooltip ──*/
.tooltip{position:fixed;background:#1e293b;border:1px solid var(--border-light);border-radius:10px;padding:.7rem .9rem;pointer-events:none;z-index:200;opacity:0;transition:opacity .12s;max-width:280px;box-shadow:0 8px 32px rgba(0,0,0,0.5)}
.tooltip.vis{opacity:1}
.tt-time{font-family:'JetBrains Mono',monospace;font-size:.78rem;color:var(--accent);margin-bottom:.35rem;font-weight:500}
.tt-count{font-size:.82rem;color:var(--text-secondary);margin-bottom:.4rem;font-weight:500}
.tt-chips{display:flex;flex-wrap:wrap;gap:3px}
.tt-chip{font-size:.72rem;padding:2px 7px;border-radius:3px;font-weight:500;color:#fff}
.tt-absent{margin-top:.35rem;font-size:.7rem;color:var(--text-muted);font-style:italic}
.tt-block-hint{margin-top:.35rem;font-family:'JetBrains Mono',monospace;font-size:.65rem;color:#ef4444;letter-spacing:.03em}

/*── Animations ──*/
@keyframes fadeUp{from{opacity:0;transform:translateY(14px)}to{opacity:1;transform:translateY(0)}}
@keyframes fadeDown{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}
/* Suppress animations on re-renders to prevent flickering */
.no-anim .hero-card,.no-anim .plan-card,.no-anim .option-card,.no-anim .insight-item,.no-anim .insights-panel,.no-anim .scenario-panel{animation:none!important;opacity:1!important;transform:none!important}

</style>
</head>
<body>

<!-- ═══ LANDING ═══ -->
<div class="landing" id="landing">
  <div class="landing-glow" id="landingGlow"></div>

  <section class="hero">
    <div class="hero-text">
      <div class="hero-eyebrow">
        <span class="logo">When2Solve</span>
        <span class="hero-badge">No servers. No signup. Runs in your browser.</span>
      </div>
      <h1 class="hero-headline">
        <span class="hero-line hero-line--dim">When2Meet shows you a heatmap.</span>
        <span class="hero-line hero-line--bright">Skip it. Get the <em>answer</em>.</span>
      </h1>
      <p class="hero-sub">Paste your When2Meet link and get instant meeting recommendations with constraints, multi-meeting coverage, and scheduling insights.</p>
      <div class="url-input-group">
        <div class="url-input-wrap">
          <i class="fa-solid fa-link url-input-icon"></i>
          <input type="url" class="url-input" id="w2mUrl" placeholder="https://when2meet.com/?12345-XXXXX" spellcheck="false" autocomplete="off">
          <button class="url-go" id="urlGo" onclick="fetchFromUrl()"><i class="fa-solid fa-arrow-right"></i></button>
        </div>
        <div class="url-status" id="urlStatus"></div>
      </div>
      <div class="hero-actions">
        <button class="cta-secondary-btn" onclick="loadDemo()"><i class="fa-solid fa-play"></i> Try with demo data</button>
      </div>
    </div>

    <div class="hero-viz">
      <div class="viz-window">
        <div class="viz-topbar">
          <span class="viz-dot viz-dot--r"></span>
          <span class="viz-dot viz-dot--y"></span>
          <span class="viz-dot viz-dot--g"></span>
          <span class="viz-title">When2Solve</span>
        </div>
        <div class="viz-body">
          <div class="w2m-overlay">
            <div class="w2m-title">when2meet.com</div>
            <div class="w2m-grid">
              <div class="w2m-corner"></div><div class="w2m-day">Mon</div><div class="w2m-day">Tue</div><div class="w2m-day">Wed</div><div class="w2m-day">Thu</div><div class="w2m-day">Fri</div>
              <div class="w2m-tl">9 AM</div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-tl">10 AM</div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-4"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-4"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-tl">11 AM</div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div>
              <div class="w2m-tl">12 PM</div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-tl">1 PM</div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-tl">2 PM</div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-4"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-tl">3 PM</div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-4"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-4"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-4"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-3"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-tl">4 PM</div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-tl">5 PM</div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-tl">6 PM</div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-2"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div>
              <div class="w2m-ts"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div><div class="w2m-cell w2m-1"></div>
            </div>
            <div class="w2m-scan"></div>
          </div>
          <div class="viz-team">
            <span class="viz-team-chip" style="--chip-color:#f472b6">Alex</span>
            <span class="viz-team-chip" style="--chip-color:#60a5fa">Blake</span>
            <span class="viz-team-chip" style="--chip-color:#a78bfa">Casey</span>
            <span class="viz-team-chip" style="--chip-color:#34d399">Dana</span>
            <span class="viz-team-chip" style="--chip-color:#fbbf24">Eli</span>
            <span class="viz-team-chip" style="--chip-color:#fb923c">Frankie</span>
            <span class="viz-team-chip" style="--chip-color:#2dd4bf">Gabi</span>
            <span class="viz-team-chip" style="--chip-color:#f87171">Harper</span>
            <span class="viz-team-chip" style="--chip-color:#818cf8">Jordan</span>
            <span class="viz-team-chip" style="--chip-color:#a3e635">Kit</span>
            <span class="viz-team-chip" style="--chip-color:#fb7185">Lee</span>
            <span class="viz-team-chip" style="--chip-color:#38bdf8">Morgan</span>
          </div>
          <div class="viz-rec">
            <div class="viz-rec-label">Recommended</div>
            <div class="viz-rec-main">
              <span class="viz-rec-day">Wednesday</span>
              <span class="viz-rec-time">3:00 &ndash; 4:00 PM</span>
            </div>
            <div class="viz-rec-dots" id="vizRecDots"></div>
            <div class="viz-rec-count">8 of 12 &mdash; without <span style="color:#818cf8">Jordan</span>, <span style="color:#a3e635">Kit</span>, <span style="color:#fb7185">Lee</span>, <span style="color:#38bdf8">Morgan</span></div>
          </div>
          <div class="viz-scenario">
            <div class="viz-scenario-header">
              <span class="viz-scenario-chev">&#9656;</span>
              <span class="viz-scenario-badge">WHAT-IF</span>
              <i class="fa-solid fa-flask" style="font-size:.6rem;color:var(--text-muted)"></i>
              <span>8 of 12 can meet. Adding a second meeting brings it to 11.</span>
            </div>
            <div class="viz-scenario-card">
              <span class="viz-scenario-icon"><i class="fa-solid fa-ghost"></i></span>
              <span><strong>1 ghost:</strong> Jordan signed up but didn&rsquo;t mark any availability</span>
            </div>
            <div class="viz-scenario-card viz-scenario-card-2">
              <span class="viz-scenario-icon"><i class="fa-solid fa-arrows-left-right"></i></span>
              <span><strong>Kit is close:</strong> extend <span style="color:var(--accent)">30 min earlier</span> on Wed to join</span>
            </div>
            <div class="viz-scenario-card viz-scenario-card-3">
              <span class="viz-scenario-icon"><i class="fa-solid fa-clone"></i></span>
              <span><strong>2 meetings help:</strong> 1 meeting: <strong>8/12</strong>. 2 meetings: <strong>11/12</strong></span>
            </div>
          </div>
          <div class="viz-alt">
            <div class="viz-alt-day">Thursday</div>
            <div class="viz-alt-time">10:00 &ndash; 11:00 AM</div>
            <div class="viz-alt-dots" id="vizAltDots"></div>
            <div class="viz-alt-count">7 of 12</div>
          </div>
          <div class="viz-insights">
            <div class="viz-insight">
              <span class="viz-insight-icon"><i class="fa-solid fa-right-left"></i></span>
              <span><strong>Ships in the night:</strong> Alex &amp; Morgan never overlap</span>
            </div>
            <div class="viz-insight">
              <span class="viz-insight-icon"><i class="fa-solid fa-bolt"></i></span>
              <span><strong>Power hour:</strong> Wed 3 PM &mdash; peak availability</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <div class="heat-divider">
    <div class="heat-bar" style="background:var(--heat-1)"></div>
    <div class="heat-bar" style="background:var(--heat-2)"></div>
    <div class="heat-bar" style="background:var(--heat-3)"></div>
    <div class="heat-bar" style="background:var(--heat-4)"></div>
    <div class="heat-bar" style="background:var(--heat-5)"></div>
    <div class="heat-bar" style="background:var(--heat-6)"></div>
    <div class="heat-bar" style="background:var(--heat-7)"></div>
    <div class="heat-bar" style="background:var(--heat-8)"></div>
  </div>

  <footer class="landing-footer">
    Built by <span class="by">Brenden Ferland</span> &middot; All solving happens in your browser &middot; <a href="https://github.com/PEEKPerformer/when2solve" target="_blank">GitHub</a>
  </footer>
</div>

<!-- ═══ SOLVER ═══ -->
<div class="solver" id="solver">
  <div class="topbar">
    <div class="topbar-left">
      <div class="topbar-brand" onclick="goHome()">WHEN2SOLVE</div>
      <span class="topbar-by">by Brenden Ferland</span>
      <div class="topbar-event" id="eventInfo"></div>
    </div>
    <div class="topbar-center">
      <div class="seg-group">
        <span class="ctrl-label">Duration</span>
        <div class="seg-btns" id="ctrlDuration">
          <div class="seg-btn" data-val="1">15m</div>
          <div class="seg-btn" data-val="2">30m</div>
          <div class="seg-btn" data-val="3">45m</div>
          <div class="seg-btn active" data-val="4">1h</div>
          <div class="seg-btn" data-val="5">1¼h</div>
          <div class="seg-btn" data-val="6">1½h</div>
          <div class="seg-btn" data-val="8">2h</div>
        </div>
      </div>
    </div>
    <div class="topbar-right">
      <div class="topbar-badge" id="participantBadge"></div>
    </div>
  </div>

  <div id="teamBar" class="team-bar"></div>
  <div id="decisions" class="decisions"></div>

  <div class="heatmap-toggle" id="heatmapToggle" onclick="toggleHeatmap()">&#9656; Explore raw availability</div>
  <div class="heatmap-section collapsed" id="heatmapSection">
    <div class="blocked-bar" id="blockedBar">
      <span class="ctrl-label">Blocked</span>
      <div class="blocked-list" id="blockedList">
        <span style="font-size:.6rem;color:var(--text-muted)">Shift+click cells below</span>
      </div>
    </div>
    <div class="heatmap-inner">
      <div class="heatmap-panel">
        <div class="heatmap-wrapper" id="heatmapWrapper">
          <div class="heatmap-grid" id="grid"></div>
        </div>
        <div class="heat-legend" id="legend"></div>
      </div>
      <div class="panel">
        <div class="panel-title">Click to filter · right-click to require</div>
        <div id="peopleList"></div>
        <div class="clear-btn" id="clearBtn" onclick="clearFilter()">&#10005; Clear filter</div>
      </div>
    </div>
  </div>
</div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip">
  <div class="tt-time" id="ttTime"></div>
  <div class="tt-count" id="ttCount"></div>
  <div class="tt-chips" id="ttChips"></div>
  <div class="tt-absent" id="ttAbsent"></div>
  <div class="tt-block-hint" id="ttBlockHint"></div>
</div>

<script>
/*═══════════════════════════════════════════════════════════════
  STATE
═══════════════════════════════════════════════════════════════*/
let STATE = {
  names: [], ids: [], available: [], times: [],
  // derived
  days: [], dayNames: [], dayMap: {}, timeLabels: [], slots: [],
  // constraints
  required: new Set(),
  blocked: new Set(),
  activePerson: null,
  // config
  numPeople: 0,
  // solution state
  dismissed: new Set(),
  currentResults: null,
  heatmapOpen: false,
};

const PCOLORS = ['#f472b6','#60a5fa','#a78bfa','#34d399','#fbbf24','#fb923c','#2dd4bf','#f87171',
                 '#c084fc','#4ade80','#fca5a5','#67e8f9','#fde047','#d946ef','#a3e635','#fb7185'];
const DAY_LABELS = {0:'Sun',1:'Mon',2:'Tue',3:'Wed',4:'Thu',5:'Fri',6:'Sat'};
function animateHeroViz() {
  // Stagger team chip animations
  document.querySelectorAll('.viz-team-chip').forEach((chip, i) => {
    chip.style.animationDelay = (2.6 + i * 0.06) + 's';
  });
  // Recommendation dots (8 present + 4 absent — 12 people total)
  const recDots = document.getElementById('vizRecDots');
  if (recDots) {
    ['#f472b6','#60a5fa','#a78bfa','#34d399','#fbbf24','#fb923c','#2dd4bf','#f87171'].forEach((c, i) => {
      const d = document.createElement('div');
      d.className = 'viz-rec-dot';
      d.style.background = c;
      d.style.animationDelay = (3.2 + i * 0.06) + 's';
      recDots.appendChild(d);
    });
    for (let j = 0; j < 4; j++) {
      const a = document.createElement('div');
      a.className = 'viz-rec-dot';
      a.style.background = 'transparent';
      a.style.border = '1px solid rgba(255,255,255,0.15)';
      a.style.animationDelay = (3.2 + (8 + j) * 0.06) + 's';
      recDots.appendChild(a);
    }
  }
  // Alternative card dots (7 present + 5 absent)
  const altDots = document.getElementById('vizAltDots');
  if (altDots) {
    ['#f472b6','#60a5fa','#a78bfa','#34d399','#fbbf24','#fb923c','#2dd4bf'].forEach((c, i) => {
      const d = document.createElement('div');
      d.className = 'viz-alt-dot';
      d.style.background = c;
      d.style.animationDelay = (4.5 + i * 0.05) + 's';
      altDots.appendChild(d);
    });
    for (let j = 0; j < 5; j++) {
      const a = document.createElement('div');
      a.className = 'viz-alt-dot absent';
      a.style.animationDelay = (4.5 + (7 + j) * 0.05) + 's';
      altDots.appendChild(a);
    }
  }
}

document.addEventListener('mousemove', (e) => {
  const glow = document.getElementById('landingGlow');
  if (glow) {
    glow.style.setProperty('--mx', e.clientX + 'px');
    glow.style.setProperty('--my', e.clientY + 'px');
  }
});

/*═══════════════════════════════════════════════════════════════
  URL FETCH (via Cloudflare Worker)
═══════════════════════════════════════════════════════════════*/
const WORKER_URL = 'https://when2solve-api.brendenferland.workers.dev';

function fetchFromUrl() {
  const input = document.getElementById('w2mUrl');
  const status = document.getElementById('urlStatus');
  const btn = document.getElementById('urlGo');
  const url = input.value.trim();

  if (!url) { input.focus(); return; }
  if (!/when2meet\.com\/?\?\d+-\w+/i.test(url)) {
    status.className = 'url-status error';
    status.textContent = 'Not a When2Meet link. Expected: when2meet.com/?12345-XXXXX';
    return;
  }

  btn.disabled = true;
  btn.classList.add('loading');
  status.className = 'url-status loading';
  status.textContent = 'Fetching availability data...';

  fetch(`${WORKER_URL}/?url=${encodeURIComponent(url)}`)
    .then(r => r.json().then(d => ({ ok: r.ok, data: d })))
    .then(({ ok, data }) => {
      btn.disabled = false;
      btn.classList.remove('loading');
      if (!ok || data.error) {
        status.className = 'url-status error';
        status.textContent = data.error || 'Unknown error';
        return;
      }
      if (!data.n || data.n.length === 0) {
        status.className = 'url-status error';
        status.textContent = 'No participants found. Has anyone filled in availability yet?';
        return;
      }
      status.className = 'url-status success';
      status.textContent = `Found ${data.n.length} participants. Loading...`;
      // Encode and launch via hash
      const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(data))));
      location.hash = encoded;
    })
    .catch(err => {
      btn.disabled = false;
      btn.classList.remove('loading');
      status.className = 'url-status error';
      status.textContent = 'Network error. Check your connection and try again.';
    });
}

// Allow Enter key in URL input
document.addEventListener('DOMContentLoaded', () => {
  const input = document.getElementById('w2mUrl');
  if (input) input.addEventListener('keydown', e => { if (e.key === 'Enter') fetchFromUrl(); });
});

/*═══════════════════════════════════════════════════════════════
  DATA DECODE
═══════════════════════════════════════════════════════════════*/
function decodeHash() {
  const hash = location.hash.slice(1);
  if (!hash) return null;
  try {
    const json = decodeURIComponent(escape(atob(hash)));
    const d = JSON.parse(json);
    if (!d.n || !d.i || !d.a || !d.t) return null;
    return d;
  } catch(e) {
    console.error('Decode error:', e);
    return null;
  }
}

function processData(raw) {
  STATE.names = raw.n;
  STATE.ids = raw.i;
  STATE.available = raw.a;
  STATE.times = raw.t;
  STATE.numPeople = raw.n.length;
  STATE.required = new Set();
  STATE.blocked = new Set();
  STATE.activePerson = null;

  // Build id→name map
  const idMap = {};
  for (let i = 0; i < STATE.numPeople; i++) idMap[STATE.ids[i]] = STATE.names[i];

  // Parse timestamps (When2Meet uses UTC time as local time, fake 1978 dates)
  // Group by day-of-week
  const daySlots = {};
  const allSlots = [];

  for (let i = 0; i < STATE.times.length; i++) {
    const ts = STATE.times[i];
    const dt = new Date(ts * 1000);
    const utcDay = dt.getUTCDay();
    const utcH = dt.getUTCHours();
    const utcM = dt.getUTCMinutes();
    const dayKey = dt.toISOString().slice(0,10); // unique date key

    if (!daySlots[dayKey]) daySlots[dayKey] = { day: utcDay, date: dayKey, slots: [] };

    const availNames = [];
    const availIds = STATE.available[i] || [];
    for (const pid of availIds) {
      if (idMap[pid]) availNames.push(idMap[pid]);
    }

    const slotObj = {
      idx: i, h: utcH, m: utcM, day: utcDay, dayKey,
      available: new Set(availNames),
      label: formatTime(utcH, utcM),
      isHour: utcM === 0,
    };
    daySlots[dayKey].slots.push(slotObj);
    allSlots.push(slotObj);
  }

  // Sort days
  const sortedDayKeys = Object.keys(daySlots).sort();
  STATE.days = sortedDayKeys;

  // Detect event type: 1978 = recurring (day-of-week), else = specific dates
  const firstYear = new Date(STATE.times[0] * 1000).getUTCFullYear();
  STATE.isRecurring = firstYear === 1978;
  const MONTH_SHORT = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  STATE.dayNames = sortedDayKeys.map(k => {
    const ds = daySlots[k];
    if (STATE.isRecurring) return DAY_LABELS[ds.day];
    const dt = new Date(k + 'T00:00:00Z');
    return DAY_LABELS[ds.day] + ' ' + MONTH_SHORT[dt.getUTCMonth()] + ' ' + dt.getUTCDate();
  });
  STATE.dayMap = daySlots;
  STATE.slots = allSlots;

  // Unique time labels (from first day)
  STATE.timeLabels = daySlots[sortedDayKeys[0]].slots.map(s => ({
    label: s.label, h: s.h, m: s.m, isHour: s.isHour
  }));
}

function formatTime(h, m) {
  const ampm = h >= 12 ? 'PM' : 'AM';
  const h12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
  return `${h12}:${String(m).padStart(2,'0')} ${ampm}`;
}

function shortTime(h, m) {
  const ampm = h >= 12 ? 'p' : 'a';
  const h12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
  return m === 0 ? `${h12}${ampm}` : `${h12}:${String(m).padStart(2,'0')}${ampm}`;
}

function pcolor(name) {
  const idx = STATE.names.indexOf(name);
  return PCOLORS[idx % PCOLORS.length];
}

function shortName(name) {
  if (name.length <= 10) return name;
  const parts = name.split(' ');
  return parts[0];
}

/*═══════════════════════════════════════════════════════════════
  SOLVER
═══════════════════════════════════════════════════════════════*/
function windowsOverlap(a, b) {
  if (a.dayKey !== b.dayKey) return false;
  const aS = a.startH * 60 + a.startM;
  const aE = a.endH * 60 + a.endM;
  const bS = b.startH * 60 + b.startM;
  const bE = b.endH * 60 + b.endM;
  return aS < bE && bS < aE;
}

function solve(overrideDuration) {
  const duration = overrideDuration || parseInt(document.getElementById('ctrlDuration').querySelector('.seg-btn.active').dataset.val);
  const required = STATE.required;
  const blocked = STATE.blocked;
  const allNames = new Set(STATE.names);

  // Build windows per day
  const windows = [];
  for (const dayKey of STATE.days) {
    const daySlots = STATE.dayMap[dayKey].slots;
    for (let i = 0; i <= daySlots.length - duration; i++) {
      const windowSlots = daySlots.slice(i, i + duration);
      // Check contiguous (15-min gaps)
      let contiguous = true;
      for (let j = 1; j < windowSlots.length; j++) {
        const diff = (windowSlots[j].h * 60 + windowSlots[j].m) - (windowSlots[j-1].h * 60 + windowSlots[j-1].m);
        if (diff !== 15) { contiguous = false; break; }
      }
      if (!contiguous) continue;

      // Check no blocked slots
      const slotKeys = windowSlots.map(s => `${s.dayKey}:${s.h}:${s.m}`);
      if (slotKeys.some(k => blocked.has(k))) continue;

      // Intersect availability across window
      let common = new Set(windowSlots[0].available);
      for (let j = 1; j < windowSlots.length; j++) {
        common = new Set([...common].filter(n => windowSlots[j].available.has(n)));
      }

      // Check required attendees
      let reqMet = true;
      for (const r of required) {
        if (!common.has(r)) { reqMet = false; break; }
      }
      if (!reqMet) continue;

      const endSlot = windowSlots[windowSlots.length - 1];
      const endM = endSlot.m + 15;
      const endH = endSlot.h + Math.floor(endM / 60);

      const key = `${dayKey}:${windowSlots[0].h}:${windowSlots[0].m}`;
      windows.push({
        key,
        dayKey, day: windowSlots[0].day,
        dayName: STATE.dayNames[STATE.days.indexOf(dayKey)],
        startH: windowSlots[0].h, startM: windowSlots[0].m,
        endH: endH, endM: endM % 60,
        count: common.size, attendees: common,
        missing: new Set([...allNames].filter(n => !common.has(n))),
        slotKeys,
        startIdx: i,
      });
    }
  }

  windows.sort((a, b) => b.count - a.count || a.startH - b.startH);

  const results = { single: [], pairs: [], coverage: 0, suggestion: null };

  // Deduplicate: only keep the best window per non-overlapping time block
  // This prevents "Not this one" from showing 15-min shifts of the same slot
  const dedupedSingles = [];
  for (const w of windows) {
    if (!dedupedSingles.some(d => windowsOverlap(d, w))) {
      dedupedSingles.push(w);
    }
  }
  results.single = dedupedSingles.slice(0, 8);

  // Check if single meeting covers everyone
  const bestSingle = windows[0];
  const singleCovers = bestSingle && bestSingle.count === STATE.numPeople;

  // Automatically compute pairs when no single meeting covers everyone
  if (!singleCovers && windows.length >= 2) {
    const topN = Math.min(windows.length, 60);
    let bestPairs = [];
    for (let i = 0; i < topN; i++) {
      for (let j = i + 1; j < topN; j++) {
        const a = windows[i], b = windows[j];

        // Skip adjacent or overlapping windows on the same day —
        // that's just one longer meeting, not a real two-meeting plan
        if (a.dayKey === b.dayKey) {
          const aEnd = a.endH * 60 + a.endM;
          const bStart = b.startH * 60 + b.startM;
          const bEnd = b.endH * 60 + b.endM;
          const aStart = a.startH * 60 + a.startM;
          if (aEnd >= bStart && aStart <= bEnd) continue;  // overlapping or adjacent
        }

        const union = new Set([...a.attendees, ...b.attendees]);
        const uncovered = [...allNames].filter(n => !union.has(n));
        const diffDay = a.dayKey !== b.dayKey;

        // Marginal value: how many NEW people does B bring that A doesn't have?
        const marginalB = [...b.attendees].filter(n => !a.attendees.has(n)).length;
        const marginalA = [...a.attendees].filter(n => !b.attendees.has(n)).length;
        const marginal = Math.max(marginalA, marginalB);

        // Score: coverage first, then marginal value, then balanced attendance
        const score = union.size * 10000 + marginal * 100 + Math.min(a.count, b.count);

        bestPairs.push({
          key: `${a.key}|${b.key}`,
          a, b, union, uncovered, score, diffDay, marginal,
          coverage: union.size,
        });
      }
    }

    // Sort: coverage → different days → marginal value → balanced attendance
    bestPairs.sort((x, y) => {
      if (y.coverage !== x.coverage) return y.coverage - x.coverage;
      if (x.diffDay !== y.diffDay) return x.diffDay ? -1 : 1;
      if (y.marginal !== x.marginal) return y.marginal - x.marginal;
      return y.score - x.score;
    });

    // Deduplicate: skip if both meetings overlap pairwise with an existing pair,
    // OR if the covered set is identical to an already-shown plan
    const dedupedPairs = [];
    const seenCoverage = new Set();
    for (const p of bestPairs) {
      // Skip if same coverage set as a previous plan
      const coverKey = [...p.union].sort().join(',');
      if (seenCoverage.has(coverKey)) continue;

      const similar = dedupedPairs.some(d =>
        (windowsOverlap(d.a, p.a) && windowsOverlap(d.b, p.b)) ||
        (windowsOverlap(d.a, p.b) && windowsOverlap(d.b, p.a))
      );
      if (!similar) {
        dedupedPairs.push(p);
        seenCoverage.add(coverKey);
      }
    }
    results.pairs = dedupedPairs.slice(0, 6);
  }

  // Coverage
  if (results.pairs.length > 0) {
    results.coverage = results.pairs[0].coverage;
  } else if (results.single.length > 0) {
    results.coverage = results.single[0].count;
  }

  // Generate suggestion if not full coverage
  if (results.coverage < STATE.numPeople) {
    const bestSol = results.pairs.length > 0 ? results.pairs[0] : null;
    if (bestSol) {
      const missing = bestSol.uncovered;
      if (missing.length > 0 && missing.length <= 2) {
        const days = bestSol.a.dayName === bestSol.b.dayName
          ? bestSol.a.dayName
          : `${bestSol.a.dayName} or ${bestSol.b.dayName}`;
        results.suggestion = `${missing.join(' & ')} can't make any combination. Check if they can extend availability on ${days}.`;
      }
    }
  }

  results.singleCovers = singleCovers;
  results.windows = windows;
  return results;
}

/*═══════════════════════════════════════════════════════════════
  RENDER
═══════════════════════════════════════════════════════════════*/
let cellEls = [];

function renderGrid() {
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  cellEls = [];

  const nDays = STATE.days.length;
  const nTimes = STATE.timeLabels.length;
  grid.style.gridTemplateColumns = `52px repeat(${nDays}, 1fr)`;

  // Corner + day headers
  const corner = document.createElement('div');
  corner.className = 'time-header';
  grid.appendChild(corner);

  STATE.days.forEach((dk, di) => {
    const dh = document.createElement('div');
    dh.className = 'day-header';
    dh.textContent = STATE.dayNames[di];
    grid.appendChild(dh);
  });

  // Rows
  STATE.timeLabels.forEach((tl, ti) => {
    const label = document.createElement('div');
    label.className = 'time-label' + (tl.isHour ? ' hour' : '');
    label.textContent = tl.isHour ? shortTime(tl.h, tl.m) : '';
    grid.appendChild(label);

    STATE.days.forEach((dk, di) => {
      const daySlots = STATE.dayMap[dk].slots;
      const slot = daySlots[ti];
      const count = slot ? slot.available.size : 0;
      const heatClass = `h${Math.min(count, 10)}`;

      const cell = document.createElement('div');
      cell.className = `cell ${heatClass}`;
      cell.dataset.di = di;
      cell.dataset.ti = ti;
      cell.dataset.dayKey = dk;
      if (slot) {
        cell.dataset.h = slot.h;
        cell.dataset.m = slot.m;
        cell.dataset.people = JSON.stringify([...slot.available]);
        cell.dataset.time = slot.label;
        cell.dataset.day = STATE.dayNames[di];
        cell.dataset.count = count;
        cell.dataset.slotKey = `${dk}:${slot.h}:${slot.m}`;
      }

      // Blocked?
      if (slot && STATE.blocked.has(`${dk}:${slot.h}:${slot.m}`)) {
        cell.classList.add('blocked');
      }

      cell.addEventListener('mouseenter', ttShow);
      cell.addEventListener('mouseleave', ttHide);
      cell.addEventListener('click', onCellClick);

      grid.appendChild(cell);
      cellEls.push(cell);
    });
  });
}

function renderLegend() {
  const el = document.getElementById('legend');
  const max = Math.min(STATE.numPeople, 10);
  let html = '<span>0</span>';
  for (let i = 0; i <= max; i++) {
    const colors = ['#111827','#1e1a2e','#2d1f3d','#4c1d6e','#7c2d8e','#b83a6a','#e04842','#f59e0b','#fbbf24','#fcd34d','#fde68a'];
    html += `<div class="hswatch" style="background:${colors[i] || colors[colors.length-1]}"></div>`;
  }
  html += `<span>${STATE.numPeople}/${STATE.numPeople}</span>`;
  el.innerHTML = html;
}

function renderPeople() {
  const list = document.getElementById('peopleList');
  list.innerHTML = '';
  const maxH = Math.max(...STATE.names.map(n => getTotalHours(n)));

  // Sort by total hours desc
  const sorted = [...STATE.names].sort((a,b) => getTotalHours(b) - getTotalHours(a));

  sorted.forEach((name, i) => {
    const h = getTotalHours(name);
    const row = document.createElement('div');
    row.className = 'person-row' + (STATE.required.has(name) ? ' required' : '');
    row.dataset.person = name;
    row.style.position = 'relative';

    row.addEventListener('click', () => toggleFilter(name));
    row.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      toggleRequired(name);
    });

    row.innerHTML = `
      <div class="pdot" style="background:${pcolor(name)};color:${pcolor(name)}"></div>
      <div class="pname">${shortName(name)}</div>
      <div class="phours">${h.toFixed(0)}h</div>
      <div class="pbar-track"><div class="pbar-fill" style="width:${(h/maxH)*100}%;background:${pcolor(name)};animation-delay:${.2+i*.06}s;opacity:0" onanimationstart="this.style.opacity=1"></div></div>
    `;
    list.appendChild(row);
  });
}

function getTotalHours(name) {
  let count = 0;
  for (const slot of STATE.slots) {
    if (slot.available.has(name)) count++;
  }
  return count * 0.25;
}

/*═══════════════════════════════════════════════════════════════
  DECISION VIEW
═══════════════════════════════════════════════════════════════*/
function updateSolutions() {
  STATE.currentResults = solve();
  renderDecisions();
  if (STATE.heatmapOpen) drawSolutionOutlines();
}

function makeDots(win, sortedNames, size) {
  let html = '';
  for (const name of sortedNames) {
    const here = win.attendees.has(name);
    const c = pcolor(name);
    html += here
      ? `<div class="att-dot present" style="background:${c}" title="${shortName(name)}"></div>`
      : `<div class="att-dot absent" style="box-shadow:inset 0 0 0 1.5px ${c}" title="${shortName(name)} — absent"></div>`;
  }
  return html;
}

function renderSingleCard(win, sortedNames) {
  const miss = [...win.missing].map(shortName).join(', ');
  const card = document.createElement('div');
  card.className = 'option-card';
  card.innerHTML = `
    <div class="card-day">${win.dayName}</div>
    <div class="card-time">${formatTime(win.startH,win.startM)} – ${formatTime(win.endH,win.endM)}</div>
    <div class="att-dots">${makeDots(win, sortedNames)}</div>
    <div class="card-count">${win.count} of ${STATE.numPeople}</div>
    ${win.missing.size > 0
      ? `<div class="card-missing">without ${miss}</div>`
      : '<div class="card-missing card-all">everyone</div>'}
    <button class="card-dismiss" onclick="dismissOption('${win.key}')">Not this one</button>`;
  return card;
}

function renderHero(win, sortedNames) {
  const miss = [...win.missing].map(shortName).join(', ');
  const hero = document.createElement('div');
  hero.className = 'hero-card';
  hero.innerHTML = `
    <div class="hero-label">Recommended</div>
    <div class="hero-main">
      <div class="hero-day">${win.dayName}</div>
      <div class="hero-time">${formatTime(win.startH,win.startM)} – ${formatTime(win.endH,win.endM)}</div>
    </div>
    <div class="hero-dots">${makeDots(win, sortedNames)}</div>
    <div class="hero-count">${win.count} of ${STATE.numPeople}</div>
    ${win.missing.size > 0
      ? `<div class="hero-missing">without ${miss}</div>`
      : '<div class="hero-missing card-all">everyone</div>'}
    <button class="hero-dismiss" onclick="dismissOption('${win.key}')">Not this one</button>`;
  return hero;
}

function renderDecisions() {
  const container = document.getElementById('decisions');
  const isRerender = container.children.length > 0;
  container.innerHTML = '';
  if (isRerender) container.classList.add('no-anim');
  const r = STATE.currentResults;
  if (!r) { container.classList.remove('no-anim'); return; }

  const sortedNames = [...STATE.names].sort((a,b) => getTotalHours(b) - getTotalHours(a));

  // --- Single meeting options (always shown) ---
  const singles = r.single.filter(w => !STATE.dismissed.has(w.key));
  if (singles.length > 0) {
    container.appendChild(renderHero(singles[0], sortedNames));
    renderScenarios(container, r, isRerender);

    const allRunners = singles.slice(1);
    if (allRunners.length > 0) {
      container.insertAdjacentHTML('beforeend', `<div class="section-head">Alternatives</div>`);
      const grid = document.createElement('div');
      grid.className = 'runners-grid';
      allRunners.forEach(win => grid.appendChild(renderSingleCard(win, sortedNames)));
      container.appendChild(grid);

      const cols = getComputedStyle(grid).gridTemplateColumns.split(' ').length;
      const overflow = [];
      while (grid.children.length > cols) {
        overflow.unshift(grid.removeChild(grid.lastChild));
      }
      if (!isRerender) [...grid.children].forEach((c, i) => { c.style.animationDelay = `${i * 0.06}s`; });

      if (overflow.length > 0) {
        const moreId = 'moreSingles';
        container.insertAdjacentHTML('beforeend',
          `<div class="show-more" onclick="toggleMore('${moreId}', this)">&#9656; ${overflow.length} more option${overflow.length > 1 ? 's' : ''}</div>`);
        const moreGrid = document.createElement('div');
        moreGrid.className = 'more-options more-grid';
        moreGrid.id = moreId;
        overflow.forEach((card, i) => { if (!isRerender) card.style.animationDelay = `${i * 0.05}s`; moreGrid.appendChild(card); });
        container.appendChild(moreGrid);
      }
    }
  }

  // --- Full coverage plans (shown automatically when no single covers everyone) ---
  if (!r.singleCovers && r.pairs.length > 0) {
    const plans = r.pairs.filter(p => !STATE.dismissed.has(p.key));
    if (plans.length > 0) {
      container.insertAdjacentHTML('beforeend', `<div class="section-head">Full Coverage Plans</div>`);

      // Show top plan, then 1-2 runner-up plans, rest behind toggle
      const visiblePlans = plans.slice(0, 3);
      const restPlans = plans.slice(3);

      visiblePlans.forEach((plan, rank) => {
        container.appendChild(renderPlanCard(plan, rank, sortedNames, isRerender));
      });

      if (restPlans.length > 0) {
        const moreId = 'morePlans';
        container.insertAdjacentHTML('beforeend',
          `<div class="show-more" onclick="toggleMore('${moreId}', this)">&#9656; ${restPlans.length} more plan${restPlans.length > 1 ? 's' : ''}</div>`);
        const moreDiv = document.createElement('div');
        moreDiv.className = 'more-options';
        moreDiv.id = moreId;
        restPlans.forEach((plan, i) => {
          moreDiv.appendChild(renderPlanCard(plan, i + 3, sortedNames, isRerender));
        });
        container.appendChild(moreDiv);
      }
    }
  }

  // --- Insights ---
  renderInsights(container);

  // --- Dismissed info ---
  if (STATE.dismissed.size > 0) {
    container.insertAdjacentHTML('beforeend',
      `<div class="dismissed-info">${STATE.dismissed.size} dismissed · <a onclick="resetDismissed()">show all</a></div>`);
  }

  if (singles.length === 0 && r.pairs.filter(p => !STATE.dismissed.has(p.key)).length === 0) {
    if (STATE.dismissed.size > 0) {
      container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);font-size:.82rem">All options dismissed.<br><a onclick="resetDismissed()" style="color:var(--accent);cursor:pointer">Show all</a></div>';
    } else {
      container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);font-size:.82rem">No valid windows found. Try adjusting constraints.</div>';
    }
  }

  if (isRerender) requestAnimationFrame(() => container.classList.remove('no-anim'));
}

function renderPlanCard(plan, rank, sortedNames, skipAnim) {
  const card = document.createElement('div');
  card.className = 'plan-card' + (rank === 0 ? ' best' : '');
  if (!skipAnim) card.style.animationDelay = `${rank * 0.08}s`;

  const onlyA = [...plan.a.attendees].filter(n => !plan.b.attendees.has(n));
  const onlyB = [...plan.b.attendees].filter(n => !plan.a.attendees.has(n));
  const both = [...plan.a.attendees].filter(n => plan.b.attendees.has(n));
  let bd = '<div class="plan-breakdown">';
  if (both.length) bd += `<span>${both.map(shortName).join(', ')}</span> at both<br>`;
  if (onlyA.length) bd += `<span>${onlyA.map(shortName).join(', ')}</span> only ${plan.a.dayName}<br>`;
  if (onlyB.length) bd += `<span>${onlyB.map(shortName).join(', ')}</span> only ${plan.b.dayName}`;
  if (plan.uncovered.length) bd += `<br>Missing: ${plan.uncovered.map(shortName).join(', ')}`;
  bd += '</div>';

  card.innerHTML = `
    <div class="plan-header">
      <div class="plan-label">${rank === 0 ? 'Best plan' : 'Plan ' + String.fromCharCode(65 + rank)}</div>
      <div class="plan-coverage-badge">${plan.coverage}/${STATE.numPeople} covered</div>
    </div>
    <button class="plan-dismiss" onclick="dismissOption('${plan.key}')" title="Dismiss">&times;</button>
    <div class="plan-meetings">
      <div class="plan-meeting">
        <div class="card-day">${plan.a.dayName}</div>
        <div class="card-time">${formatTime(plan.a.startH,plan.a.startM)} – ${formatTime(plan.a.endH,plan.a.endM)}</div>
        <div class="att-dots">${makeDots(plan.a, sortedNames)}</div>
        <div class="card-count">${plan.a.count}/${STATE.numPeople}</div>
      </div>
      <div class="plan-connector">+</div>
      <div class="plan-meeting">
        <div class="card-day">${plan.b.dayName}</div>
        <div class="card-time">${formatTime(plan.b.startH,plan.b.startM)} – ${formatTime(plan.b.endH,plan.b.endM)}</div>
        <div class="att-dots">${makeDots(plan.b, sortedNames)}</div>
        <div class="card-count">${plan.b.count}/${STATE.numPeople}</div>
      </div>
    </div>
    ${bd}`;
  return card;
}

function toggleMore(id, el) {
  const div = document.getElementById(id);
  if (!div) return;
  const open = div.classList.toggle('open');
  const n = div.children.length;
  el.innerHTML = open
    ? '&#9662; Hide'
    : `&#9656; ${n} more option${n > 1 ? 's' : ''}`;
}

function renderInsights(container) {
  const insights = computeInsights();
  if (insights.length === 0) return;
  const panel = document.createElement('div');
  panel.className = 'insights-panel';
  let html = '<div class="section-head" style="margin-top:0;margin-bottom:.4rem">Scheduling Insights</div>';
  insights.forEach(ins => {
    html += `<div class="insight-item"><span class="insight-icon">${ins.icon}</span><span>${ins.text}</span></div>`;
  });
  panel.innerHTML = html;
  container.appendChild(panel);
}

function renderScenarios(container, results, isRerender) {
  if (!results || results.single.length === 0) return;
  const bottlenecks = computeBottlenecks(results);
  if (!bottlenecks) return;
  const { suggestions, summary } = computeSuggestions(results, bottlenecks);
  if (suggestions.length === 0) return;

  const panel = document.createElement('div');
  panel.className = 'scenario-panel';

  const autoExpand = bottlenecks.bestCount / bottlenecks.N < 0.6;
  const chevClass = autoExpand ? 'chev open' : 'chev';
  const bodyClass = autoExpand ? 'scenario-body open' : 'scenario-body';

  let headerText = summary || 'What-if scenarios available';
  let html = `<div class="scenario-summary" onclick="this.querySelector('.chev').classList.toggle('open');this.nextElementSibling.classList.toggle('open')">
    <span class="${chevClass}">&#9656;</span>
    <span class="scenario-badge">WHAT-IF</span>
    <i class="fa-solid fa-flask" style="color:var(--text-muted);font-size:.8rem"></i>
    <span>${headerText}</span>
  </div>`;

  html += `<div class="${bodyClass}">`;
  html += '<div class="section-head" style="margin-top:0;margin-bottom:.5rem;font-size:.7rem">Scenario Explorer</div>';

  for (const s of suggestions) {
    html += `<div class="scenario-card">
      <span class="scenario-icon">${s.icon}</span>
      <strong>${s.title}:</strong> ${s.text}
    </div>`;
  }

  html += '</div>';
  panel.innerHTML = html;
  container.appendChild(panel);
}

function computeInsights() {
  const insights = [];
  const names = STATE.names;
  const slots = STATE.slots;
  const N = names.length;
  if (N === 0 || slots.length === 0) return insights;

  // --- Precompute per-person data ---
  const hours = names.map(n => ({ name: n, h: getTotalHours(n) }));
  hours.sort((a,b) => a.h - b.h);
  const least = hours[0], most = hours[hours.length - 1];

  // Per-person per-day hours and earliest/latest times
  const personDayH = {};   // name → { dayKey → hours }
  const personEarliest = {};  // name → earliest hour (decimal)
  const personLatest = {};    // name → latest hour (decimal)
  for (const n of names) {
    personDayH[n] = {};
    personEarliest[n] = 24;
    personLatest[n] = 0;
  }
  for (const s of slots) {
    const t = s.h + s.m / 60;
    for (const n of s.available) {
      personDayH[n][s.dayKey] = (personDayH[n][s.dayKey] || 0) + 0.25;
      if (t < personEarliest[n]) personEarliest[n] = t;
      if (t + 0.25 > personLatest[n]) personLatest[n] = t + 0.25;
    }
  }

  // Pairwise overlap matrix
  const overlap = {};
  for (let i = 0; i < N; i++) {
    for (let j = i + 1; j < N; j++) {
      let c = 0;
      for (const s of slots) {
        if (s.available.has(names[i]) && s.available.has(names[j])) c++;
      }
      overlap[`${i}:${j}`] = c;
    }
  }

  // --- 0. Zero-hours callout — people who signed up but marked nothing ---
  const zeroNames = hours.filter(h => h.h === 0).map(h => h.name);
  if (zeroNames.length > 0) {
    const who = zeroNames.length === 1
      ? `<strong>${shortName(zeroNames[0])}</strong> has`
      : `<strong>${zeroNames.map(shortName).join(', ')}</strong> have`;
    insights.push({ icon: '<i class="fa-solid fa-ghost"></i>', text: `${who} <span class="warn">zero availability</span> — they may not have filled it out yet` });
  }

  // --- 1. Early Bird / Night Owl ---
  // Skip zero-hours people
  let earliestPerson = null, latestPerson = null;
  for (const n of names) {
    if (getTotalHours(n) === 0) continue; // skip zero-hours people
    if (!earliestPerson || personEarliest[n] < personEarliest[earliestPerson]) earliestPerson = n;
    if (!latestPerson || personLatest[n] > personLatest[latestPerson]) latestPerson = n;
  }
  if (earliestPerson && latestPerson && earliestPerson !== latestPerson) {
    const spread = personLatest[latestPerson] - personEarliest[earliestPerson];
    if (spread >= 4) { // Only show if ≥4h spread — genuinely different schedules
      const eTime = formatTime(Math.floor(personEarliest[earliestPerson]), Math.round((personEarliest[earliestPerson] % 1) * 60));
      const lH = personLatest[latestPerson];
      const lTime = formatTime(Math.floor(lH), Math.round((lH % 1) * 60));
      insights.push({ icon: '<i class="fa-solid fa-sun"></i>', text: `<strong>${shortName(earliestPerson)}</strong> is the early bird (from ${eTime}) — <strong>${shortName(latestPerson)}</strong> is the night owl (until ${lTime})` });
    }
  }

  // --- 2. Morning vs Afternoon team ---
  // Normalize by number of slots in each period so 9am-4pm doesn't auto-skew afternoon
  let mAvail = 0, mPossible = 0, aAvail = 0, aPossible = 0;
  for (const s of slots) {
    if (s.h < 12) { mAvail += s.available.size; mPossible += N; }
    else { aAvail += s.available.size; aPossible += N; }
  }
  if (mPossible > 0 && aPossible > 0) {
    const mRate = Math.round(mAvail / mPossible * 100);
    const aRate = Math.round(aAvail / aPossible * 100);
    const diff = Math.abs(mRate - aRate);
    if (diff > 20) {
      const skew = mRate > aRate ? 'mornings' : 'afternoons';
      const pct = Math.max(mRate, aRate);
      insights.push({ icon: skew === 'mornings' ? '<i class="fa-solid fa-sun"></i>' : '<i class="fa-solid fa-moon"></i>', text: `The team skews toward <strong>${skew}</strong> — ${pct}% fill rate ${skew === 'mornings' ? 'before noon' : 'after noon'} vs ${Math.min(mRate,aRate)}% ${skew === 'mornings' ? 'after' : 'before'}` });
    }
  }

  // --- Helper: display hours/minutes nicely ---
  function fmtHrs(slots) {
    const h = slots * 0.25;
    if (h === 0) return 'never';
    if (h < 1) return `${Math.round(h * 60)}min`;
    return `${h % 1 === 0 ? h : h.toFixed(1)}h`;
  }

  // --- 3. Best Buds (most overlap pair) ---
  // Only consider people with >0 hours (skip zero-availability ghosts)
  let maxOv = 0, bestPair = null;
  let minOv = Infinity, hardPair = null;
  const activeIndices = [];
  for (let i = 0; i < N; i++) {
    if (getTotalHours(names[i]) > 0) activeIndices.push(i);
  }
  for (let ii = 0; ii < activeIndices.length; ii++) {
    for (let jj = ii + 1; jj < activeIndices.length; jj++) {
      const i = activeIndices[ii], j = activeIndices[jj];
      const c = overlap[`${i}:${j}`];
      if (c > maxOv) { maxOv = c; bestPair = [names[i], names[j]]; }
      if (c < minOv) { minOv = c; hardPair = [names[i], names[j]]; }
    }
  }
  if (bestPair && maxOv > 0) {
    // Show as percentage of the smaller person's availability for readability
    const aSz = slots.filter(s => s.available.has(bestPair[0])).length;
    const bSz = slots.filter(s => s.available.has(bestPair[1])).length;
    const smaller = Math.min(aSz, bSz);
    const pct = smaller > 0 ? Math.round(maxOv / smaller * 100) : 0;
    if (pct >= 70) { // Show when overlap is notable
      const flavor = pct >= 95 ? 'scheduling clones' : pct >= 85 ? 'scheduling soulmates' : 'easiest pair to co-schedule';
      insights.push({ icon: '<i class="fa-solid fa-user-group"></i>', text: `<strong>Best buds:</strong> ${shortName(bestPair[0])} + ${shortName(bestPair[1])} share <span class="hl">${pct}%</span> of their availability — ${flavor}` });
    }
  }

  // --- 4. Ships in the Night (hardest pair) ---
  // Only show when both people have meaningful availability (≥2h each) but barely overlap
  if (hardPair) {
    const hpA = getTotalHours(hardPair[0]), hpB = getTotalHours(hardPair[1]);
    const bothActive = hpA >= 2 && hpB >= 2;
    if (bothActive && minOv === 0) {
      insights.push({ icon: '<i class="fa-solid fa-right-left"></i>', text: `<strong>Ships in the night:</strong> ${shortName(hardPair[0])} + ${shortName(hardPair[1])} have <span class="warn">zero overlap</span> — never available at the same time` });
    } else if (bothActive && minOv <= 4) {
      insights.push({ icon: '<i class="fa-solid fa-right-left"></i>', text: `<strong>Ships in the night:</strong> ${shortName(hardPair[0])} + ${shortName(hardPair[1])} overlap only <span class="warn">${fmtHrs(minOv)}</span> — hardest to get in a room together` });
    }
  }

  // --- 5. Unanimous Windows ---
  // Group contiguous unanimous slots into windows. Only show for groups ≤ 10 —
  // for larger groups, unanimous slots are nearly impossible and the insight is noise.
  if (N >= 3 && N <= 10) {
    const unanBlocks = [];
    for (const dk of STATE.days) {
      const daySlots = STATE.dayMap[dk].slots;
      let blockStart = null, blockLen = 0;
      for (let i = 0; i < daySlots.length; i++) {
        if (daySlots[i].available.size === N) {
          if (blockStart === null) blockStart = i;
          blockLen++;
        } else {
          if (blockStart !== null) {
            unanBlocks.push({ dayKey: dk, dayName: STATE.dayNames[STATE.days.indexOf(dk)], start: daySlots[blockStart], len: blockLen });
            blockStart = null; blockLen = 0;
          }
        }
      }
      if (blockStart !== null) {
        unanBlocks.push({ dayKey: dk, dayName: STATE.dayNames[STATE.days.indexOf(dk)], start: daySlots[blockStart], len: blockLen });
      }
    }
    if (unanBlocks.length > 0) {
      const descs = unanBlocks.map(b => {
        const dur = (b.len * 0.25);
        const durStr = dur >= 1 ? `${dur}h` : `${dur * 60}min`;
        return `${b.dayName} ${shortTime(b.start.h, b.start.m)} (${durStr})`;
      });
      const label = unanBlocks.length === 1 ? '1 unanimous window' : `${unanBlocks.length} unanimous windows`;
      insights.push({ icon: '<i class="fa-solid fa-bullseye"></i>', text: `<span class="hl">${label}</span> where the whole team is free: ${descs.join(', ')}` });
    }
  }

  // --- 6. The Linchpin ---
  // Who, if removed, opens the most new full-attendance windows?
  // Deduplicate overlapping windows so we count distinct time blocks, not 15-min shifts
  const r = STATE.currentResults;
  if (r && r.single.length > 0) {
    const bestCount = r.single[0].count;
    if (bestCount < N) {
      const allWindows = r.windows || r.single;
      let bestGain = 0, linchpin = null;
      for (const n of names) {
        // Collect windows that become full if this person is dropped
        const full = allWindows.filter(w => {
          const ct = w.attendees.has(n) ? w.count - 1 : w.count;
          return ct >= N - 1;
        });
        // Deduplicate overlapping windows
        const deduped = [];
        for (const w of full) {
          if (!deduped.some(d => windowsOverlap(d, w))) deduped.push(w);
        }
        if (deduped.length > bestGain) { bestGain = deduped.length; linchpin = n; }
      }
      if (linchpin && bestGain > 0) {
        insights.push({ icon: '<i class="fa-solid fa-key"></i>', text: `<strong>The linchpin:</strong> ${shortName(linchpin)} — dropping them as required would unlock <span class="hl">${bestGain}</span> perfect-attendance ${bestGain === 1 ? 'window' : 'windows'}` });
      }
    }
  }

  // --- 7. Ghost Day ---
  const dayTotals = {};
  for (const dk of STATE.days) {
    dayTotals[dk] = 0;
    for (const s of STATE.dayMap[dk].slots) {
      dayTotals[dk] += s.available.size;
    }
  }
  const dayEntries = Object.entries(dayTotals);
  if (dayEntries.length > 1) {
    dayEntries.sort((a,b) => a[1] - b[1]);
    const [worstDk, worstCount] = dayEntries[0];
    const [bestDk, bestCount] = dayEntries[dayEntries.length - 1];
    const dropPct = Math.round((1 - worstCount / bestCount) * 100);
    if (dropPct > 40) {
      const worstName = STATE.dayNames[STATE.days.indexOf(worstDk)];
      const bestName = STATE.dayNames[STATE.days.indexOf(bestDk)];
      insights.push({ icon: '<i class="fa-solid fa-calendar-xmark"></i>', text: `<strong>Ghost day:</strong> ${worstName} has ${dropPct}% less availability than ${bestName}` });
    }
  }

  // --- 8. The Minimalist / The Accommodator ---
  if (least.h > 0 && most.h >= least.h * 3 && N >= 4) {
    insights.push({ icon: '<i class="fa-solid fa-scale-balanced"></i>', text: `<strong>${shortName(least.name)}</strong> offered ${fmtHrs(Math.round(least.h / 0.25))} — <strong>${shortName(most.name)}</strong> offered ${fmtHrs(Math.round(most.h / 0.25))} <span class="soft">(${(most.h / least.h).toFixed(1)}× more)</span>` });
  }

  // --- 9. "If only..." nudge ---
  if (STATE.currentResults && STATE.currentResults.suggestion) {
    insights.push({ icon: '<i class="fa-solid fa-lightbulb"></i>', text: STATE.currentResults.suggestion });
  }

  // --- 10. Lunch Hour Crunch ---
  let lunchAvail = 0, lunchSlots = 0;
  for (const s of slots) {
    if (s.h >= 12 && s.h < 13) {
      lunchSlots++;
      lunchAvail += s.available.size;
    }
  }
  if (lunchSlots > 0) {
    const lunchPct = Math.round(lunchAvail / (lunchSlots * N) * 100);
    if (lunchPct < 40) {
      insights.push({ icon: '<i class="fa-solid fa-utensils"></i>', text: `Only <span class="warn">${lunchPct}%</span> of the team is free over lunch (12–1 PM) — slim pickings for a midday meeting` });
    }
  }

  // --- 11. The Anchor — someone available every single slot ---
  {
    const totalSlots = slots.length;
    const anchors = names.filter(n => {
      let c = 0;
      for (const s of slots) { if (s.available.has(n)) c++; }
      return c === totalSlots;
    });
    if (anchors.length === 1) {
      insights.push({ icon: '<i class="fa-solid fa-anchor"></i>', text: `<strong>${shortName(anchors[0])}</strong> is available <span class="hl">every single slot</span> — the scheduling anchor` });
    } else if (anchors.length > 1) {
      insights.push({ icon: '<i class="fa-solid fa-anchor"></i>', text: `<span class="hl">${anchors.length} people</span> (${anchors.map(shortName).join(', ')}) are available every single slot` });
    }
  }

  // --- 12. The Sniper — someone offered very little time ---
  if (N >= 3) {
    const snipers = hours.filter(h => h.h > 0 && h.h <= 1.5);
    if (snipers.length === 1) {
      insights.push({ icon: '<i class="fa-solid fa-crosshairs"></i>', text: `<strong>${shortName(snipers[0].name)}</strong> offered only <span class="warn">${fmtHrs(Math.round(snipers[0].h / 0.25))}</span> all week — every slot counts` });
    } else if (snipers.length > 1 && snipers.length <= 3) {
      insights.push({ icon: '<i class="fa-solid fa-crosshairs"></i>', text: `<span class="warn">${snipers.length} people</span> offered 1.5h or less each — tight windows to work with` });
    }
  }

  // --- 13. The Twins — two people with >90% schedule overlap ---
  if (N >= 3) {
    let bestTwinPct = 0, twinPair = null;
    for (let i = 0; i < N; i++) {
      for (let j = i + 1; j < N; j++) {
        const ov = overlap[`${i}:${j}`];
        // Union = slotsA + slotsB - overlap
        let sA = 0, sB = 0;
        for (const s of slots) {
          if (s.available.has(names[i])) sA++;
          if (s.available.has(names[j])) sB++;
        }
        const union = sA + sB - ov;
        if (union > 0) {
          const pct = ov / union;
          if (pct > bestTwinPct) { bestTwinPct = pct; twinPair = [names[i], names[j]]; }
        }
      }
    }
    if (bestTwinPct >= 0.95 && twinPair) {
      insights.push({ icon: '<i class="fa-solid fa-clone"></i>', text: `<strong>${shortName(twinPair[0])}</strong> and <strong>${shortName(twinPair[1])}</strong> have <span class="hl">${Math.round(bestTwinPct * 100)}%</span> identical availability — scheduling clones` });
    }
  }

  // --- 14. Friday Flight Risk — Friday drops >40% vs best day ---
  if (STATE.isRecurring) {
    const fridayKey = STATE.days.find(dk => STATE.dayMap[dk].day === 5);
    if (fridayKey && dayEntries.length > 1) {
      const friCount = dayTotals[fridayKey] || 0;
      const bestDayEntry = dayEntries[dayEntries.length - 1];
      if (bestDayEntry[0] !== fridayKey && bestDayEntry[1] > 0) {
        const friDrop = Math.round((1 - friCount / bestDayEntry[1]) * 100);
        if (friDrop >= 40) {
          const bestDayName = STATE.dayNames[STATE.days.indexOf(bestDayEntry[0])];
          insights.push({ icon: '<i class="fa-solid fa-plane-departure"></i>', text: `<strong>Friday flight risk:</strong> Friday has <span class="warn">${friDrop}%</span> less availability than ${bestDayName} — the weekend starts early` });
        }
      }
    }
  }

  // --- 15. The Power Hour — one specific hour dramatically beats the rest ---
  {
    const hourBuckets = {};
    for (const s of slots) {
      const key = `${s.dayKey}:${s.h}`;
      const dayName = STATE.dayNames[STATE.days.indexOf(s.dayKey)];
      if (!hourBuckets[key]) hourBuckets[key] = { count: 0, slots: 0, dayName, h: s.h };
      hourBuckets[key].count += s.available.size;
      hourBuckets[key].slots++;
    }
    const buckets = Object.values(hourBuckets).filter(b => b.slots >= 2); // at least 30min
    if (buckets.length >= 4) {
      buckets.sort((a, b) => (b.count / b.slots) - (a.count / a.slots));
      const top = buckets[0];
      const avg = buckets.reduce((s, b) => s + b.count / b.slots, 0) / buckets.length;
      const topAvg = top.count / top.slots;
      if (topAvg >= N * 0.8 && topAvg > avg * 1.3) {
        const timeStr = formatTime(top.h, 0).replace(':00 ', ' ');
        const nextH = top.h + 1;
        const endStr = formatTime(nextH, 0).replace(':00 ', ' ');
        insights.push({ icon: '<i class="fa-solid fa-bolt"></i>', text: `<strong>Power hour:</strong> ${top.dayName} ${timeStr}–${endStr} is peak availability at <span class="hl">${Math.round(topAvg)}/${N}</span>` });
      }
    }
  }

  // --- 16. Three's a Crowd — three people who pair up fine but never all overlap ---
  // Only for groups ≤ 10 — with many people, bad trios are statistically guaranteed and uninteresting
  if (N >= 4 && N <= 10) {
    let crowd = null;
    outer: for (let i = 0; i < N && !crowd; i++) {
      if (getTotalHours(names[i]) === 0) continue;
      for (let j = i + 1; j < N && !crowd; j++) {
        if (getTotalHours(names[j]) === 0) continue;
        for (let k = j + 1; k < N; k++) {
          if (getTotalHours(names[k]) === 0) continue;
          const ij = overlap[`${i}:${j}`], ik = overlap[`${i}:${k}`], jk = overlap[`${j}:${k}`];
          // Require meaningful pairwise overlap (≥ 1 hour each)
          if (ij >= 4 && ik >= 4 && jk >= 4) {
            // Check if all three are ever simultaneously free
            let tripleCount = 0;
            for (const s of slots) {
              if (s.available.has(names[i]) && s.available.has(names[j]) && s.available.has(names[k])) {
                tripleCount++;
                break;
              }
            }
            if (tripleCount === 0) {
              crowd = [names[i], names[j], names[k]];
              break outer;
            }
          }
        }
      }
    }
    if (crowd) {
      insights.push({ icon: '<i class="fa-solid fa-triangle-exclamation"></i>', text: `<strong>Three's a crowd:</strong> ${shortName(crowd[0])}, ${shortName(crowd[1])}, and ${shortName(crowd[2])} each pair up fine, but all three together? <span class="warn">Never</span>` });
    }
  }

  // --- 17. The Split Shift — someone with a midday gap (requires ≥ 1h gap) ---
  {
    for (const n of names) {
      if (getTotalHours(n) === 0) continue;
      let foundSplit = false;
      for (const dk of STATE.days) {
        const daySlots = STATE.dayMap[dk].slots;
        const avail = daySlots.map(s => s.available.has(n));
        // Look for pattern: available → gap of 2+ slots → available again
        let state = 'before', gapLen = 0;
        for (let i = 0; i < avail.length; i++) {
          if (state === 'before' && avail[i]) state = 'in';
          else if (state === 'in' && !avail[i]) { state = 'gap'; gapLen = 1; }
          else if (state === 'gap' && !avail[i]) gapLen++;
          else if (state === 'gap' && avail[i] && gapLen >= 4) { foundSplit = true; break; }
          else if (state === 'gap' && avail[i]) state = 'in'; // small blip, reset
        }
        if (foundSplit) {
          const dayName = STATE.dayNames[STATE.days.indexOf(dk)];
          insights.push({ icon: '<i class="fa-solid fa-scissors"></i>', text: `<strong>${shortName(n)}</strong> has a split shift on ${dayName} — available, disappears, then comes back` });
          break;
        }
      }
      if (foundSplit) break; // Only show one
    }
  }

  // --- 18. The Core Crew — a subset always available together ---
  if (N >= 4 && N <= 12) {
    // Find the largest group of 3+ people where every slot that ANY of them is free, ALL of them are free
    // Simpler approach: find the group with most shared slots (all simultaneously free)
    let bestCrew = null, bestCrewSlots = 0;
    for (let i = 0; i < N; i++) {
      if (getTotalHours(names[i]) === 0) continue;
      for (let j = i + 1; j < N; j++) {
        if (getTotalHours(names[j]) === 0) continue;
        for (let k = j + 1; k < N; k++) {
          if (getTotalHours(names[k]) === 0) continue;
          let shared = 0;
          for (const s of slots) {
            if (s.available.has(names[i]) && s.available.has(names[j]) && s.available.has(names[k])) shared++;
          }
          if (shared > bestCrewSlots) { bestCrewSlots = shared; bestCrew = [names[i], names[j], names[k]]; }
        }
      }
    }
    // Only show if the core crew has significantly more overlap than average
    if (bestCrew && bestCrewSlots >= 16) { // 4+ hours together
      const crewHrs = (bestCrewSlots * 0.25);
      insights.push({ icon: '<i class="fa-solid fa-people-group"></i>', text: `<strong>Core crew:</strong> ${bestCrew.map(shortName).join(', ')} are available together for <span class="hl">${crewHrs}h</span> this week — easiest trio to schedule` });
    }
  }

  // --- 19. Doppelganger — detect duplicate/near-duplicate names ---
  // When2Meet lets people sign up with trailing spaces, slightly different names, etc.
  {
    const found = [];
    for (let i = 0; i < N && found.length === 0; i++) {
      for (let j = i + 1; j < N; j++) {
        const a = names[i].trim().toLowerCase(), b = names[j].trim().toLowerCase();
        if (a === b) {
          found.push([names[i], names[j], 'same name (one may have a trailing space)']);
          break;
        }
      }
    }
    if (found.length > 0) {
      const [n1, n2, reason] = found[0];
      insights.push({ icon: '<i class="fa-solid fa-people-arrows"></i>', text: `<strong>Doppelgänger?</strong> "${shortName(n1)}" and "${shortName(n2)}" — ${reason}. Might be a duplicate entry` });
    }
  }

  // --- 20. One-Day Wonder — someone only available on 1 day when event spans 3+ ---
  if (STATE.days.length >= 3) {
    for (const n of names) {
      if (getTotalHours(n) === 0) continue;
      const activeDays = STATE.days.filter(dk => personDayH[n][dk] > 0);
      if (activeDays.length === 1) {
        const dayName = STATE.dayNames[STATE.days.indexOf(activeDays[0])];
        insights.push({ icon: '<i class="fa-solid fa-calendar-day"></i>', text: `<strong>One-day wonder:</strong> ${shortName(n)} is only free on <span class="hl">${dayName}</span> — all-or-nothing scheduling` });
        break; // Only show one
      }
    }
  }

  // --- 21. The Bottleneck — removing one person would let everyone else meet ---
  if (N >= 4 && r && r.single.length > 0) {
    const bestCount = r.single[0].count;
    if (bestCount < N && bestCount >= N - 1) {
      // Best single window covers N-1. Find who's the odd one out
      const bestWin = r.single[0];
      const missing = names.filter(n => !bestWin.attendees.has(n));
      if (missing.length === 1 && getTotalHours(missing[0]) > 0) {
        insights.push({ icon: '<i class="fa-solid fa-user-xmark"></i>', text: `<strong>The bottleneck:</strong> without ${shortName(missing[0])}, everyone else can meet — they're the scheduling wild card` });
      }
    }
  }

  // --- 22. Lunch Rush — everyone free at 12-1pm on some day ---
  {
    const activeNames = names.filter(n => getTotalHours(n) > 0);
    if (activeNames.length >= 4) {
      for (const dk of STATE.days) {
        const lunchSlots = STATE.dayMap[dk].slots.filter(s => s.h >= 12 && s.h < 13);
        if (lunchSlots.length === 0) continue;
        const allFree = lunchSlots.some(s => activeNames.every(n => s.available.has(n)));
        if (allFree) {
          const dayName = STATE.dayNames[STATE.days.indexOf(dk)];
          insights.push({ icon: '<i class="fa-solid fa-burger"></i>', text: `<strong>Lunch rush:</strong> everyone's free for lunch on <span class="hl">${dayName}</span> — maybe bring snacks?` });
          break;
        }
      }
    }
  }

  // --- 23. The Overachiever — one person with ≥2.5× median availability ---
  {
    const activeH = hours.filter(h => h.h > 0).map(h => h.h).sort((a,b) => a - b);
    if (activeH.length >= 4) {
      const median = activeH[Math.floor(activeH.length / 2)];
      const top = hours[hours.length - 1]; // most hours (hours is sorted ascending)
      if (median > 0 && top.h >= median * 2.5) {
        insights.push({ icon: '<i class="fa-solid fa-trophy"></i>', text: `<strong>The overachiever:</strong> ${shortName(top.name)} offered <span class="hl">${top.h.toFixed(0)}h</span> — ${(top.h / median).toFixed(1)}× more than the median (${median.toFixed(0)}h)` });
      }
    }
  }

  // --- 24. Schedule Tetris — two people whose union covers every slot ---
  if (N >= 3 && activeIndices.length >= 2) {
    let tetrisPair = null;
    const totalSlots = slots.length;
    for (let ii = 0; ii < activeIndices.length && !tetrisPair; ii++) {
      for (let jj = ii + 1; jj < activeIndices.length; jj++) {
        const i = activeIndices[ii], j = activeIndices[jj];
        const ov = overlap[`${i}:${j}`];
        const sA = Math.round(getTotalHours(names[i]) / 0.25);
        const sB = Math.round(getTotalHours(names[j]) / 0.25);
        const union = sA + sB - ov;
        if (union >= totalSlots) { tetrisPair = [names[i], names[j]]; break; }
      }
    }
    if (tetrisPair) {
      insights.push({ icon: '<i class="fa-solid fa-puzzle-piece"></i>', text: `<strong>Schedule Tetris:</strong> ${shortName(tetrisPair[0])} + ${shortName(tetrisPair[1])} together cover <span class="hl">every single slot</span> — they fill the board` });
    }
  }

  // --- 25. Marathon Runner — someone available 6+ continuous hours on one day ---
  {
    let marathon = null;
    for (const n of names) {
      if (getTotalHours(n) === 0) continue;
      for (const dk of STATE.days) {
        const daySlots = STATE.dayMap[dk].slots;
        let run = 0, bestRun = 0;
        for (let i = 0; i < daySlots.length; i++) {
          if (daySlots[i].available.has(n)) { run++; bestRun = Math.max(bestRun, run); }
          else run = 0;
        }
        if (bestRun >= 40) { // 40 × 15min = 10h
          const hrs = bestRun * 0.25;
          const dayName = STATE.dayNames[STATE.days.indexOf(dk)];
          marathon = { name: n, hrs, day: dayName };
          break;
        }
      }
      if (marathon) break;
    }
    if (marathon) {
      insights.push({ icon: '<i class="fa-solid fa-person-running"></i>', text: `<strong>Marathon runner:</strong> ${shortName(marathon.name)} has a <span class="hl">${marathon.hrs}h</span> unbroken stretch on ${marathon.day}` });
    }
  }

  // --- 26. The Consistent One — same time range every day they're available ---
  if (STATE.days.length >= 3) {
    for (const n of names) {
      if (getTotalHours(n) === 0) continue;
      const activeDayKeys = STATE.days.filter(dk => personDayH[n][dk] > 0);
      if (activeDayKeys.length < 3) continue; // need 3+ days to be "consistent"
      // Collect the set of time-of-day indices per day
      const dayTimesets = activeDayKeys.map(dk => {
        const set = new Set();
        for (const s of STATE.dayMap[dk].slots) {
          if (s.available.has(n)) set.add(s.h * 60 + s.m);
        }
        return set;
      });
      // Check if all days have identical time sets
      const ref = dayTimesets[0];
      const allSame = dayTimesets.every(ts => ts.size === ref.size && [...ts].every(t => ref.has(t)));
      if (allSame && ref.size >= 4) { // at least 1h consistent block
        const startMin = Math.min(...ref);
        const endMin = Math.max(...ref) + 15;
        const startStr = formatTime(Math.floor(startMin / 60), startMin % 60);
        const endStr = formatTime(Math.floor(endMin / 60), endMin % 60);
        insights.push({ icon: '<i class="fa-solid fa-robot"></i>', text: `<strong>The consistent one:</strong> ${shortName(n)} marked <span class="hl">${startStr}–${endStr}</span> on all ${activeDayKeys.length} days — clockwork precision` });
        break;
      }
    }
  }

  // --- 27. The Social Butterfly — person with the most total overlap with everyone ---
  if (activeIndices.length >= 4) {
    // Sum total overlap slots between this person and all others
    const totalOv = {};
    for (const idx of activeIndices) totalOv[idx] = 0;
    for (let ii = 0; ii < activeIndices.length; ii++) {
      for (let jj = ii + 1; jj < activeIndices.length; jj++) {
        const i = activeIndices[ii], j = activeIndices[jj];
        const ov = overlap[`${i}:${j}`];
        totalOv[i] += ov;
        totalOv[j] += ov;
      }
    }
    const ranked = [...activeIndices].sort((a, b) => totalOv[b] - totalOv[a]);
    const bestIdx = ranked[0], secondIdx = ranked[1];
    const bestOv = totalOv[bestIdx], secondOv = totalOv[secondIdx];
    const avgOv = activeIndices.reduce((s, i) => s + totalOv[i], 0) / activeIndices.length;
    // Show if the butterfly has ≥25% more total overlap than #2, and ≥1.3× average
    if (bestOv > secondOv * 1.25 && bestOv >= avgOv * 1.3) {
      const bestHrs = (bestOv * 0.25).toFixed(0);
      insights.push({ icon: '<i class="fa-solid fa-wand-magic-sparkles"></i>', text: `<strong>Social butterfly:</strong> ${shortName(names[bestIdx])} has <span class="hl">${bestHrs}h</span> of combined overlap with everyone — most broadly compatible person` });
    }
  }

  // --- 28. Availability Desert — 2+ hour dead zone where nobody is free ---
  {
    let worstDesert = null;
    for (const dk of STATE.days) {
      const daySlots = STATE.dayMap[dk].slots;
      let run = 0, bestRun = 0, bestStart = 0, runStart = 0;
      for (let i = 0; i < daySlots.length; i++) {
        if (daySlots[i].available.size === 0) {
          if (run === 0) runStart = i;
          run++;
          if (run > bestRun) { bestRun = run; bestStart = runStart; }
        } else { run = 0; }
      }
      if (bestRun >= 8) { // 8 × 15min = 2h
        const hrs = bestRun * 0.25;
        const dayName = STATE.dayNames[STATE.days.indexOf(dk)];
        const startSlot = daySlots[bestStart];
        const startStr = formatTime(startSlot.h, startSlot.m);
        if (!worstDesert || hrs > worstDesert.hrs) {
          worstDesert = { day: dayName, hrs, startStr };
        }
      }
    }
    if (worstDesert) {
      insights.push({ icon: '<i class="fa-solid fa-temperature-empty"></i>', text: `<strong>Availability desert:</strong> <span class="warn">${worstDesert.hrs}h dead zone</span> on ${worstDesert.day} starting ${worstDesert.startStr} — nobody is free` });
    }
  }

  // --- 29. The Clustering — group splits into early crew vs late crew ---
  if (activeIndices.length >= 5) {
    // Compute each person's average available hour
    const personAvgH = {};
    for (const idx of activeIndices) {
      const n = names[idx];
      let sumH = 0, cnt = 0;
      for (const s of slots) {
        if (s.available.has(n)) { sumH += s.h + s.m / 60; cnt++; }
      }
      personAvgH[idx] = cnt > 0 ? sumH / cnt : 0;
    }
    // Split at the median average hour (data-driven, not fixed noon)
    const avgHours = activeIndices.map(i => personAvgH[i]).sort((a, b) => a - b);
    const medianH = avgHours[Math.floor(avgHours.length / 2)];
    const earlyGroup = activeIndices.filter(i => personAvgH[i] < medianH);
    const lateGroup = activeIndices.filter(i => personAvgH[i] >= medianH);
    if (earlyGroup.length >= 2 && lateGroup.length >= 2) {
      // Check if the two groups have meaningfully different scheduling overlap
      let withinOv = 0, withinN = 0;
      for (const group of [earlyGroup, lateGroup]) {
        for (let i = 0; i < group.length; i++)
          for (let j = i + 1; j < group.length; j++) {
            withinOv += overlap[`${Math.min(group[i],group[j])}:${Math.max(group[i],group[j])}`] || 0;
            withinN++;
          }
      }
      let crossOv = 0, crossN = 0;
      for (const e of earlyGroup)
        for (const l of lateGroup) {
          crossOv += overlap[`${Math.min(e,l)}:${Math.max(e,l)}`] || 0;
          crossN++;
        }
      const avgWithin = withinN > 0 ? withinOv / withinN : 0;
      const avgCross = crossN > 0 ? crossOv / crossN : 0;
      // Show if within-group overlap is notably higher than cross-group
      if (avgWithin > 0 && avgCross > 0 && avgWithin >= avgCross * 1.5) {
        const earlyAvg = earlyGroup.reduce((s, i) => s + personAvgH[i], 0) / earlyGroup.length;
        const lateAvg = lateGroup.reduce((s, i) => s + personAvgH[i], 0) / lateGroup.length;
        const earlyLabel = earlyAvg < 12 ? 'morning' : 'earlier';
        const lateLabel = lateAvg >= 17 ? 'evening' : 'later';
        insights.push({ icon: '<i class="fa-solid fa-arrows-split-up-and-left"></i>', text: `<strong>Two worlds:</strong> ${earlyGroup.length} ${earlyLabel} people vs ${lateGroup.length} ${lateLabel} people — the group naturally splits into two scheduling crews` });
      }
    }
  }

  // --- 30. Crowd Favorite Day — supermajority agree on one best day ---
  if (STATE.days.length >= 3 && activeIndices.length >= 4) {
    const dayVotes = {};
    for (const dk of STATE.days) dayVotes[dk] = 0;
    for (const idx of activeIndices) {
      const n = names[idx];
      let bestDay = null, bestH = 0;
      for (const dk of STATE.days) {
        const h = personDayH[n][dk] || 0;
        if (h > bestH) { bestH = h; bestDay = dk; }
      }
      if (bestDay) dayVotes[bestDay]++;
    }
    const [topDay, topVotes] = Object.entries(dayVotes).sort((a, b) => b[1] - a[1])[0];
    const pct = Math.round(topVotes / activeIndices.length * 100);
    if (pct >= 60 && topVotes >= 3) {
      const dayName = STATE.dayNames[STATE.days.indexOf(topDay)];
      insights.push({ icon: '<i class="fa-solid fa-star"></i>', text: `<strong>Crowd favorite:</strong> <span class="hl">${topVotes}/${activeIndices.length}</span> people are most available on ${dayName} — the clear winner` });
    }
  }

  // --- 31. Mirror Schedules — two people who together cover lots but never overlap ---
  if (activeIndices.length >= 2) {
    let bestMirror = null;
    const totalSlots = slots.length;
    for (let ii = 0; ii < activeIndices.length && !bestMirror; ii++) {
      for (let jj = ii + 1; jj < activeIndices.length; jj++) {
        const i = activeIndices[ii], j = activeIndices[jj];
        const ov = overlap[`${i}:${j}`];
        const sA = Math.round(getTotalHours(names[i]) / 0.25);
        const sB = Math.round(getTotalHours(names[j]) / 0.25);
        const union = sA + sB - ov;
        const smaller = Math.min(sA, sB);
        // High coverage (≥70% of all slots) but minimal overlap (≤10% of smaller person)
        if (union >= totalSlots * 0.7 && smaller >= 8 && ov <= smaller * 0.1) {
          const coverPct = Math.round(union / totalSlots * 100);
          bestMirror = { a: names[i], b: names[j], coverPct, ov };
          break;
        }
      }
    }
    if (bestMirror) {
      insights.push({ icon: '<i class="fa-solid fa-arrows-rotate"></i>', text: `<strong>Mirror schedules:</strong> ${shortName(bestMirror.a)} + ${shortName(bestMirror.b)} cover <span class="hl">${bestMirror.coverPct}%</span> of slots together but ${bestMirror.ov === 0 ? 'never' : 'almost never'} overlap — scheduling yin and yang` });
    }
  }

  return insights;
}

/*═══════════════════════════════════════════════════════════════
  SCENARIO EXPLORER — bottleneck + suggestion engine
═══════════════════════════════════════════════════════════════*/
function computeBottlenecks(results) {
  const names = STATE.names;
  const N = names.length;
  if (N === 0 || !results || results.single.length === 0) return null;

  // 3a. Ghost detection — signed up but 0 availability, or near-ghost (< 1hr total)
  const ghosts = names.filter(n => getTotalHours(n) === 0);
  const nearGhosts = names.filter(n => { const h = getTotalHours(n); return h > 0 && h < 1; });

  // 3b. Duplicate detection — whitespace-trim exact match only
  const seen = {};
  const duplicates = [];
  for (const n of names) {
    const key = n.trim().toLowerCase();
    if (seen[key]) duplicates.push([seen[key], n]);
    else seen[key] = n;
  }

  // 3c. Per-person removal analysis
  const bestWindow = results.single[0];
  const bestCount = bestWindow.count;
  const allWindows = results.windows || results.single;
  const perPerson = [];

  for (const n of names) {
    const isGhost = ghosts.includes(n);
    const inBest = bestWindow.attendees.has(n);
    let gain = 0;
    if (!isGhost) {
      // How many N-1 attendance windows open if this person is dropped?
      const full = allWindows.filter(w => {
        const ct = w.attendees.has(n) ? w.count - 1 : w.count;
        return ct >= N - 1;
      });
      const deduped = [];
      for (const w of full) {
        if (!deduped.some(d => windowsOverlap(d, w))) deduped.push(w);
      }
      gain = deduped.length;
    }
    // Count near-misses: windows where this person is the only one missing
    const nearMisses = allWindows.filter(w => w.count === N - 1 && !w.attendees.has(n));
    perPerson.push({ name: n, gain, nearMisses: nearMisses.length, isGhost, inBest });
  }

  // 3d. Slot proximity analysis — for each person missing from best window
  const slotSuggestions = [];
  for (const n of [...bestWindow.missing]) {
    if (ghosts.includes(n) || nearGhosts.includes(n)) continue;
    // Find this person's availability on the best window's day
    const dayKey = bestWindow.dayKey;
    const daySlots = STATE.dayMap[dayKey] ? STATE.dayMap[dayKey].slots : [];
    const personSlots = daySlots.filter(s => s.available.has(n));

    if (personSlots.length === 0) {
      slotSuggestions.push({ name: n, type: 'no-day' });
      continue;
    }

    // Best window time range in minutes
    const wStart = bestWindow.startH * 60 + bestWindow.startM;
    const wEnd = bestWindow.endH * 60 + bestWindow.endM;

    // Person's slot edges on this day
    const pTimes = personSlots.map(s => s.h * 60 + s.m);
    const pStart = Math.min(...pTimes);
    const pEnd = Math.max(...pTimes) + 15; // slot end = start + 15min

    // Gap from person's availability to the window
    let gapMin = Infinity;
    let direction = '';
    if (pEnd <= wStart) {
      gapMin = wStart - pEnd;
      direction = 'later';
    } else if (pStart >= wEnd) {
      gapMin = pStart - wEnd;
      direction = 'earlier';
    } else {
      // Overlaps but not fully: find which edge they need to extend
      if (pStart > wStart) { gapMin = pStart - wStart; direction = 'earlier'; }
      else if (pEnd < wEnd) { gapMin = wEnd - pEnd; direction = 'later'; }
    }

    if (gapMin <= 60) {
      slotSuggestions.push({ name: n, type: 'extend', gapMin, direction });
    } else {
      // Count how many 15-min slots they'd need to add
      const neededSlots = Math.ceil(gapMin / 15);
      if (neededSlots <= 3) {
        slotSuggestions.push({ name: n, type: 'add-slots', neededSlots, direction });
      } else {
        slotSuggestions.push({ name: n, type: 'too-far', gapMin });
      }
    }
  }

  return { ghosts, nearGhosts, duplicates, perPerson, slotSuggestions, bestWindow, bestCount, N };
}

function computeSuggestions(results, bottlenecks) {
  const suggestions = [];
  if (!bottlenecks) return { suggestions, summary: '' };
  const { ghosts, nearGhosts, duplicates, perPerson, slotSuggestions, bestWindow, bestCount, N } = bottlenecks;

  // Silence rules
  if (results.singleCovers) return { suggestions, summary: '' };
  if (bestCount / N >= 0.9) return { suggestions, summary: '' };

  // Priority 0: Ghosts + near-ghosts
  const allGhostish = ghosts.length + nearGhosts.length;
  if (allGhostish > 0) {
    let parts = [];
    if (ghosts.length > 0) {
      parts.push(`<strong>${ghosts.join(', ')}</strong> signed up but didn\u2019t mark any availability`);
    }
    if (nearGhosts.length > 0) {
      const nearParts = nearGhosts.map(n => {
        const mins = Math.round(getTotalHours(n) * 60);
        return `${n} (${mins}min)`;
      });
      parts.push(`<strong>${nearParts.join(', ')}</strong> marked less than 1 hour total`);
    }
    suggestions.push({
      type: 'ghost', priority: 0,
      icon: '<i class="fa-solid fa-ghost"></i>',
      title: `${allGhostish} ghost${allGhostish > 1 ? 's' : ''}`,
      text: parts.join('. Also, ')
    });
  }

  // Priority 1: Duration trade-off
  const currentDuration = parseInt(document.getElementById('ctrlDuration').querySelector('.seg-btn.active').dataset.val);
  if (currentDuration >= 4) {
    const shorterOptions = currentDuration >= 8 ? [currentDuration - 4, currentDuration - 2] : [currentDuration - 2];
    for (const shorter of shorterOptions) {
      if (shorter < 2) continue;
      const altResults = solve(shorter);
      if (altResults.single.length > 0) {
        const altBest = altResults.single[0].count;
        const gainPeople = altBest - bestCount;
        const threshold = Math.max(2, Math.ceil(N * 0.15));
        if (gainPeople >= threshold) {
          const durStr = shorter * 0.25 >= 1 ? `${(shorter * 0.25)}h` : `${shorter * 15}min`;
          const curStr = currentDuration * 0.25 >= 1 ? `${(currentDuration * 0.25)}h` : `${currentDuration * 15}min`;
          suggestions.push({
            type: 'duration', priority: 1,
            icon: '<i class="fa-solid fa-clock"></i>',
            title: 'Shorter meeting helps',
            text: `At <span class="hl">${durStr}</span> instead of ${curStr}, <strong>${gainPeople} more people</strong> can attend (${altBest}/${N})`
          });
          break;
        }
      }
    }
  }

  // Priority 2: Extend availability
  const extends_ = slotSuggestions.filter(s => s.type === 'extend');
  for (const ext of extends_.slice(0, 2)) {
    if (suggestions.length >= 4) break;
    const durStr = ext.gapMin <= 15 ? '15 min' : `${ext.gapMin} min`;
    suggestions.push({
      type: 'extend', priority: 2,
      icon: '<i class="fa-solid fa-arrows-left-right"></i>',
      title: `${ext.name} is close`,
      text: `If <strong>${ext.name}</strong> extended <span class="hl">${durStr} ${ext.direction}</span> on ${bestWindow.dayName}, they\u2019d join the best meeting`
    });
  }

  // Priority 3: Add slots
  const addSlots = slotSuggestions.filter(s => s.type === 'add-slots');
  for (const add of addSlots.slice(0, 1)) {
    if (suggestions.length >= 4) break;
    const slotStr = add.neededSlots === 1 ? '1 slot' : `${add.neededSlots} slots`;
    suggestions.push({
      type: 'add-slots', priority: 3,
      icon: '<i class="fa-solid fa-plus"></i>',
      title: `${add.name} needs ${slotStr}`,
      text: `If <strong>${add.name}</strong> added ${slotStr} ${add.direction} on ${bestWindow.dayName}, they\u2019d join the best meeting`
    });
  }

  // Priority 4: Flexible — dropping 1 person opens many perfect-attendance windows
  if (suggestions.length < 4) {
    const flexible = perPerson
      .filter(p => !p.isGhost && p.gain >= 2)
      .sort((a, b) => b.gain - a.gain);
    if (flexible.length > 0) {
      const top = flexible[0];
      suggestions.push({
        type: 'flexible', priority: 4,
        icon: '<i class="fa-solid fa-unlock"></i>',
        title: `${top.name} is a constraint`,
        text: `Without <strong>${top.name}</strong>\u2019s constraint, <span class="hl">${top.gain} perfect-attendance windows</span> open`
      });
    }
  }

  // Priority 5: Pair cost-benefit
  if (suggestions.length < 4 && !results.singleCovers && results.pairs.length > 0) {
    const bestPair = results.pairs[0];
    const pairCoverage = bestPair.coverage;
    const singleCoverage = bestCount;
    const pairGain = pairCoverage - singleCoverage;
    if (pairGain >= 2) {
      suggestions.push({
        type: 'pair', priority: 5,
        icon: '<i class="fa-solid fa-clone"></i>',
        title: '2 meetings help',
        text: `1 meeting: <strong>${singleCoverage}/${N}</strong>. 2 meetings: <strong>${pairCoverage}/${N}</strong>. Second meeting picks up <span class="hl">${pairGain}</span> more`
      });
    }
  }

  // Duplicates — append as a note if present
  if (duplicates.length > 0 && suggestions.length < 4) {
    const dupNames = duplicates.map(d => `"${d[0]}" / "${d[1]}"`).join(', ');
    suggestions.push({
      type: 'duplicate', priority: 6,
      icon: '<i class="fa-solid fa-copy"></i>',
      title: 'Possible duplicates',
      text: `These names look like the same person: ${dupNames}. If so, results may overcount availability.`
    });
  }

  // Summary line for collapsed state
  let summary = '';
  if (bestCount < N) {
    summary = `${bestCount} of ${N} can meet`;
    if (results.pairs.length > 0) {
      const pairCov = results.pairs[0].coverage;
      if (pairCov > bestCount) summary += `. Adding a second meeting brings it to ${pairCov}`;
    }
    summary += '.';
  }

  return { suggestions: suggestions.slice(0, 4), summary };
}

function renderTeamBar() {
  const bar = document.getElementById('teamBar');
  if (!bar) return;
  bar.innerHTML = '';
  const sorted = [...STATE.names].sort((a,b) => getTotalHours(b) - getTotalHours(a));
  const allH = sorted.map(n => getTotalHours(n));
  const avgH = allH.reduce((a,b) => a+b, 0) / allH.length;
  const minH = Math.min(...allH), maxH = Math.max(...allH);

  bar.insertAdjacentHTML('beforeend', '<span class="team-label">Team</span>');
  sorted.forEach(name => {
    const h = getTotalHours(name);
    const isReq = STATE.required.has(name);
    const chip = document.createElement('span');
    chip.className = 'team-chip' + (isReq ? ' required' : '');
    chip.dataset.person = name;
    chip.title = isReq ? 'Click to un-require' : 'Click to require in all meetings';
    chip.onclick = () => { toggleRequired(name); renderTeamBar(); };
    chip.innerHTML = `<span class="chip-dot" style="background:${pcolor(name)}"></span>
      <span>${shortName(name)}</span><span class="chip-hours">${h.toFixed(0)}h</span>
      ${isReq ? '<span class="chip-req">req</span>' : ''}`;
    bar.appendChild(chip);
  });
  bar.insertAdjacentHTML('beforeend',
    `<span class="team-stats">avg ${avgH.toFixed(0)}h · range ${minH.toFixed(0)}&ndash;${maxH.toFixed(0)}h</span>`);
}

function dismissOption(key) {
  STATE.dismissed.add(key);
  renderDecisions();
  if (STATE.heatmapOpen) drawSolutionOutlines();
}

function resetDismissed() {
  STATE.dismissed.clear();
  renderDecisions();
  if (STATE.heatmapOpen) drawSolutionOutlines();
}

function toggleHeatmap() {
  STATE.heatmapOpen = !STATE.heatmapOpen;
  const sec = document.getElementById('heatmapSection');
  const tog = document.getElementById('heatmapToggle');
  if (STATE.heatmapOpen) {
    sec.classList.remove('collapsed');
    tog.innerHTML = '&#9662; Raw availability';
    if (!sec.dataset.rendered) {
      renderGrid();
      renderLegend();
      renderPeople();
      sec.dataset.rendered = 'true';
    }
    drawSolutionOutlines();
  } else {
    sec.classList.add('collapsed');
    tog.innerHTML = '&#9656; Explore raw availability';
  }
}

function drawSolutionOutlines() {
  document.querySelectorAll('.sol-outline').forEach(e => e.remove());
  if (!STATE.currentResults) return;
  const r = STATE.currentResults;
  if (!r.singleCovers && r.pairs.length > 0) {
    const best = r.pairs.filter(p => !STATE.dismissed.has(p.key))[0];
    if (best) { drawOutline(best.a, 'A'); drawOutline(best.b, 'B'); }
  } else if (r.single.length > 0) {
    const best = r.single.filter(w => !STATE.dismissed.has(w.key))[0];
    if (best) drawOutline(best, 'BEST');
  }
}

function drawOutline(win, label) {
  const grid = document.getElementById('grid');
  const di = STATE.days.indexOf(win.dayKey);
  const ti = STATE.timeLabels.findIndex(t => t.h === win.startH && t.m === win.startM);
  const dur = parseInt(document.getElementById('ctrlDuration').querySelector('.seg-btn.active').dataset.val);
  const tiEnd = ti + dur - 1;

  const firstCell = grid.querySelector(`.cell[data-di="${di}"][data-ti="${ti}"]`);
  const lastCell = grid.querySelector(`.cell[data-di="${di}"][data-ti="${tiEnd}"]`);
  if (!firstCell || !lastCell) return;

  const gridRect = grid.getBoundingClientRect();
  const fRect = firstCell.getBoundingClientRect();
  const lRect = lastCell.getBoundingClientRect();

  const outline = document.createElement('div');
  outline.className = 'sol-outline';
  outline.style.left = (fRect.left - gridRect.left - 2) + 'px';
  outline.style.top = (fRect.top - gridRect.top - 2) + 'px';
  outline.style.width = (fRect.width + 4) + 'px';
  outline.style.height = (lRect.bottom - fRect.top + 4) + 'px';

  const tag = document.createElement('div');
  tag.className = 'sol-tag';
  tag.textContent = label;
  outline.appendChild(tag);

  grid.style.position = 'relative';
  grid.appendChild(outline);
}

/*═══════════════════════════════════════════════════════════════
  INTERACTIONS
═══════════════════════════════════════════════════════════════*/
function ttShow(e) {
  const cell = e.currentTarget;
  if (!cell.dataset.people) return;
  const tt = document.getElementById('tooltip');
  const people = JSON.parse(cell.dataset.people);
  const count = parseInt(cell.dataset.count);
  const allNames = STATE.names;

  document.getElementById('ttTime').textContent = `${cell.dataset.day} · ${cell.dataset.time}`;
  document.getElementById('ttCount').textContent = `${count}/${STATE.numPeople} available`;

  const chipsEl = document.getElementById('ttChips');
  chipsEl.innerHTML = '';
  people.forEach(n => {
    const chip = document.createElement('span');
    chip.className = 'tt-chip';
    chip.textContent = shortName(n);
    chip.style.background = pcolor(n) + '33';
    chip.style.color = pcolor(n);
    chipsEl.appendChild(chip);
  });

  const absent = allNames.filter(n => !people.includes(n));
  document.getElementById('ttAbsent').textContent = absent.length ? `Missing: ${absent.map(shortName).join(', ')}` : '';

  const isBlocked = cell.classList.contains('blocked');
  document.getElementById('ttBlockHint').textContent = isBlocked ? '● BLOCKED — click to unblock' : 'Shift+click to block this slot';

  tt.classList.add('vis');
  const r = cell.getBoundingClientRect();
  let left = r.right + 10, top = r.top - 10;
  if (left + 240 > window.innerWidth) left = r.left - 250;
  if (top + 120 > window.innerHeight) top = window.innerHeight - 130;
  if (top < 8) top = 8;
  tt.style.left = left + 'px';
  tt.style.top = top + 'px';
}

function ttHide() {
  document.getElementById('tooltip').classList.remove('vis');
}

function onCellClick(e) {
  const cell = e.currentTarget;
  if (!cell.dataset.slotKey) return;
  // Shift+click or regular click to toggle block
  const key = cell.dataset.slotKey;
  if (e.shiftKey || (!STATE.activePerson && e.button === 0)) {
    // Only block on shift+click to avoid confusion with person filter
    if (e.shiftKey) {
      if (STATE.blocked.has(key)) {
        STATE.blocked.delete(key);
        cell.classList.remove('blocked');
      } else {
        STATE.blocked.add(key);
        cell.classList.add('blocked');
      }
      renderBlockedList();
      updateSolutions();
    }
  }
}

function renderBlockedList() {
  const el = document.getElementById('blockedList');
  if (STATE.blocked.size === 0) {
    el.innerHTML = '<span style="font-size:.6rem;color:var(--text-muted)">Shift+click cells below</span>';
    return;
  }
  el.innerHTML = '';
  for (const key of STATE.blocked) {
    const [dk, h, m] = key.split(':');
    const di = STATE.days.indexOf(dk);
    const dayName = STATE.dayNames[di] || dk;
    const chip = document.createElement('span');
    chip.className = 'blocked-chip';
    chip.innerHTML = `${dayName} ${shortTime(+h,+m)} <span class="x">×</span>`;
    chip.onclick = () => {
      STATE.blocked.delete(key);
      const cell = document.querySelector(`.cell[data-slot-key="${key}"]`);
      if (cell) cell.classList.remove('blocked');
      renderBlockedList();
      updateSolutions();
    };
    el.appendChild(chip);
  }
}

function toggleFilter(name) {
  if (STATE.activePerson === name) {
    clearFilter();
    return;
  }
  STATE.activePerson = name;
  document.querySelectorAll('.person-row').forEach(r => r.classList.toggle('active', r.dataset.person === name));
  document.getElementById('clearBtn').classList.add('show');

  cellEls.forEach(cell => {
    if (!cell.dataset.people) return;
    const people = JSON.parse(cell.dataset.people);
    if (people.includes(name)) {
      cell.classList.add('person-on');
      cell.classList.remove('person-off');
      cell.style.background = pcolor(name);
    } else {
      cell.classList.remove('person-on');
      cell.classList.add('person-off');
    }
  });
}

function clearFilter() {
  STATE.activePerson = null;
  document.querySelectorAll('.person-row').forEach(r => r.classList.remove('active'));
  document.getElementById('clearBtn').classList.remove('show');
  cellEls.forEach(cell => {
    cell.classList.remove('person-on', 'person-off');
    cell.style.background = '';
  });
}

function toggleRequired(name) {
  if (STATE.required.has(name)) {
    STATE.required.delete(name);
  } else {
    STATE.required.add(name);
  }
  document.querySelectorAll('.person-row').forEach(r => {
    r.classList.toggle('required', STATE.required.has(r.dataset.person));
  });
  updateSolutions();
}

function onConstraintChange() {
  updateSolutions();
}

// Segmented button click handlers
document.querySelectorAll('.seg-btns').forEach(group => {
  group.querySelectorAll('.seg-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      group.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      onConstraintChange();
    });
  });
});

function goHome() {
  location.hash = '';
  document.getElementById('solver').classList.remove('active');
  document.getElementById('landing').classList.remove('hidden');
  document.getElementById('w2mUrl').value = '';
  const status = document.getElementById('urlStatus');
  status.className = 'url-status';
  status.textContent = '';
}

/*═══════════════════════════════════════════════════════════════
  INIT
═══════════════════════════════════════════════════════════════*/
function init() {
  animateHeroViz();

  const raw = decodeHash();
  if (raw) {
    launchSolver(raw);
  }

  window.addEventListener('hashchange', () => {
    const raw = decodeHash();
    if (raw) launchSolver(raw);
  });

  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      if (document.getElementById('solver').classList.contains('active')) updateSolutions();
    }, 150);
  });
}

function launchSolver(raw) {
  processData(raw);
  document.getElementById('landing').classList.add('hidden');
  document.getElementById('solver').classList.add('active');
  document.getElementById('participantBadge').textContent = `${STATE.numPeople} participants`;
  const eventName = raw.e ? raw.e : null;
  document.getElementById('eventInfo').textContent = eventName
    ? `${eventName} · ${STATE.numPeople} people`
    : `${STATE.days.length} days · ${STATE.timeLabels.length} time slots`;

  renderTeamBar();
  updateSolutions();
}

/*═══════════════════════════════════════════════════════════════
  DEMO DATA
═══════════════════════════════════════════════════════════════*/
const DEMOS = [{"v":1,"e":"Writing Group","n":["Alex","Blake","Casey","Dana","Ellis","Frankie","Gabi","Harper"],"i":[1,2,3,4,5,6,7,8],"t":[279795600,279796500,279797400,279798300,279799200,279800100,279801000,279801900,279802800,279803700,279804600,279805500,279806400,279807300,279808200,279809100,279810000,279810900,279811800,279812700,279813600,279814500,279815400,279816300,279817200,279818100,279819000,279819900,279882000,279882900,279883800,279884700,279885600,279886500,279887400,279888300,279889200,279890100,279891000,279891900,279892800,279893700,279894600,279895500,279896400,279897300,279898200,279899100,279900000,279900900,279901800,279902700,279903600,279904500,279905400,279906300,279968400,279969300,279970200,279971100,279972000,279972900,279973800,279974700,279975600,279976500,279977400,279978300,279979200,279980100,279981000,279981900,279982800,279983700,279984600,279985500,279986400,279987300,279988200,279989100,279990000,279990900,279991800,279992700,280054800,280055700,280056600,280057500,280058400,280059300,280060200,280061100,280062000,280062900,280063800,280064700,280065600,280066500,280067400,280068300,280069200,280070100,280071000,280071900,280072800,280073700,280074600,280075500,280076400,280077300,280078200,280079100,280141200,280142100,280143000,280143900,280144800,280145700,280146600,280147500,280148400,280149300,280150200,280151100,280152000,280152900,280153800,280154700,280155600,280156500,280157400,280158300,280159200,280160100,280161000,280161900,280162800,280163700,280164600,280165500],"a":[[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],[1,2,3,4,5,7,8],[1,2,3,4,5,7,8],[1,2,3,5,7,8],[1,2,3,5,7,8],[1,2,3,5,7,8],[1,2,3,5,7,8],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[1,2,3,5,7],[3,4,5,6,7],[3,4,5,6,7],[3,4,5,6,7],[3,4,5,6,7],[4,5,6,7],[4,5,6,7],[4,5,6,7],[4,5,6,7],[4,5,6],[4,5,6],[4,5,6],[4,5,6],[3,4,5,6],[3,4,5,6],[3,4,5,6],[3,4,5,6],[3,4,5,6,8],[3,4,5,6,8],[3,4,5,6,8],[3,4,5,6,7,8],[2,3,4,6,7,8],[2,3,4,6,7,8],[2,4,7,8],[2,4,7,8],[2,7,8],[2,7,8],[2,7,8],[2,7,8],[2,4,5,6,7,8],[2,4,5,6,7,8],[2,4,5,6,7,8],[2,4,5,6,7,8],[2,4,5,7,8],[2,4,5,7,8],[2,4,5,7,8],[2,4,5,7,8],[2,5,7,8],[2,5,7,8],[2,5,7,8],[2,5,7,8],[5,6,7,8],[5,6,7,8],[5,6,7,8],[5,6,7,8],[5,6,7,8],[5,6,7,8],[5,6,7,8],[5,6,7,8],[2,5,6,8],[2,5,6,8],[2,5,6,8],[2,5,6,8],[2,4,5,6],[2,4,5,6],[2,4,5,6],[2,4,5,6],[3,4,5,6],[3,4,5,6],[3,4,5,6],[3,4,5,6],[3,4,5,6],[1,3,4,5,6],[1,3,4,5,6],[1,3,4,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,5,6],[1,2,6],[1,2,6],[1,2,3],[1,2,3],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[2,4,5,6,7,8],[2,4,5,6,7],[2,4,5,6,7],[2,4,5,6,7],[2,4,5,6,7],[2,4,5,6,7],[2,4,5,6,7],[2,4,5,6,7],[2,4,6],[2,4,6],[2,4,6],[2,4,6],[4,6],[4,6],[4,6],[4,6],[],[],[],[],[],[],[],[],[],[],[],[]]},{"v":1,"e":"Project Kickoff","n":["Alex","Blake","Casey","Dana","Ellis","Frankie","Gabi","Harper","Jordan","Kit","Lee","Morgan"],"i":[1,2,3,4,5,6,7,8,9,10,11,12],"t":[279795600,279796500,279797400,279798300,279799200,279800100,279801000,279801900,279802800,279803700,279804600,279805500,279806400,279807300,279808200,279809100,279810000,279810900,279811800,279812700,279813600,279814500,279815400,279816300,279817200,279818100,279819000,279819900,279820800,279821700,279822600,279823500,279824400,279825300,279826200,279827100,279828000,279828900,279829800,279830700,279882000,279882900,279883800,279884700,279885600,279886500,279887400,279888300,279889200,279890100,279891000,279891900,279892800,279893700,279894600,279895500,279896400,279897300,279898200,279899100,279900000,279900900,279901800,279902700,279903600,279904500,279905400,279906300,279907200,279908100,279909000,279909900,279910800,279911700,279912600,279913500,279914400,279915300,279916200,279917100,279968400,279969300,279970200,279971100,279972000,279972900,279973800,279974700,279975600,279976500,279977400,279978300,279979200,279980100,279981000,279981900,279982800,279983700,279984600,279985500,279986400,279987300,279988200,279989100,279990000,279990900,279991800,279992700,279993600,279994500,279995400,279996300,279997200,279998100,279999000,279999900,280000800,280001700,280002600,280003500,280054800,280055700,280056600,280057500,280058400,280059300,280060200,280061100,280062000,280062900,280063800,280064700,280065600,280066500,280067400,280068300,280069200,280070100,280071000,280071900,280072800,280073700,280074600,280075500,280076400,280077300,280078200,280079100,280080000,280080900,280081800,280082700,280083600,280084500,280085400,280086300,280087200,280088100,280089000,280089900,280141200,280142100,280143000,280143900,280144800,280145700,280146600,280147500,280148400,280149300,280150200,280151100,280152000,280152900,280153800,280154700,280155600,280156500,280157400,280158300,280159200,280160100,280161000,280161900,280162800,280163700,280164600,280165500,280166400,280167300,280168200,280169100,280170000,280170900,280171800,280172700,280173600,280174500,280175400,280176300],"a":[[4],[4,6],[4],[4],[4],[4],[4],[4],[4],[4],[4],[4],[],[],[],[],[],[],[],[],[2,7],[2,7],[1,2,7],[1,2,7],[1,2,7],[1,2,6,7],[1,2,6,7],[1,2,6,7],[1,2,6,7],[1,2,6,7],[1,2,6,7],[1,2,6,7],[1,2,4,5,6,7],[1,2,4,5,6,7],[1,2,4,5,6,7],[1,2,4,5,6,7],[1,2,4,6,7],[1,2,4,6,7],[1,2,4,6,7],[1,2,4,7],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[6],[6],[6],[6],[2,3,6,9],[2,3,6,9],[2,3,6,9],[2,3,6,9],[2,3,9],[2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,3,9],[1,2,4],[1,2,4],[1,2,4],[1,2,4],[1,2,4],[1,2,4],[1,2,4],[1,2,4],[2,4,11],[2,4,11],[2,4,11],[2,4,8,11],[2,4,8,10,11],[2,4,8,10,11],[2,4,8,10,11],[2,4,8,10,11],[2,4,8,10,11],[2,4,8,10,11],[2,4,8,10,11],[2,4,8,10,11],[2,8,10,11],[2,8,10,11],[2,8,10,11],[2,8,10,11],[2,3,6,8,9,10,11],[2,3,6,8,9,10,11],[2,3,6,8,9,10,11],[2,3,6,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,6,7,8,9,10,11],[2,3,7,8,9,10,11],[2,3,7,8,9,10,11],[3,7,8,9,10,11],[3,7,8,9,10,11],[4,8,10,11],[4,8,10,11],[4,8,10,11],[4,8,10,11],[1,4,7,8,10,11],[1,4,7,8,10,11],[1,4,7,8,10,11],[1,4,7,8,10,11],[4,6,11],[4,11],[4,6,11],[4,6,11],[4,6,11],[4,6,11],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[6],[6],[6,8],[6,8],[1,2,3,5,6,8,9,10,11],[1,2,3,5,6,8,9,10,11],[1,2,3,5,6,8,9,10,11],[1,2,3,5,6,8,9,10,11],[1,2,3,5,8,9,10,11],[1,2,3,5,8,9,10,11],[1,2,3,5,8,9,10,11],[1,2,3,5,8,9,10,11],[2,3,8,9,10,11],[2,3,8,9,10,11],[2,3,8,9,10,11],[2,3,8,9,10,11],[2,3,8,9,10,11],[2,3,8,9,10,11],[2,3,8,9,10,11],[2,3,8,9,10,11],[1,2,4,8,10,11],[1,2,4,8,10,11],[1,2,4,8,10,11],[1,2,4,8,10,11],[1,2,4,8,10,11],[1,2,4,8,10,11],[1,2,4,8,10,11],[1,2,4,8,10,11],[4,11],[4,11],[4,11],[4,11],[4,11],[4,11],[4,11],[4,11],[4],[4],[1,4],[1,4],[1],[1],[1],[1],[6],[6],[6],[6],[6],[6],[6,8],[6,8],[1,6,8,11],[1,6,8,10,11],[1,6,8,10,11],[1,8,10,11],[1,8,10,11],[1,8,10,11],[1,8,10,11],[1,8,10,11],[1,4,8,10,11],[1,4,8,10,11],[1,4,8,10,11],[1,4,8,10,11],[1,4,8,10,11],[1,4,8,10,11],[1,4,8,10,11],[1,4,8,10,11]]},{"v":1,"e":"Committee Meeting","n":["Alex","Blake","Casey","Dana","Ellis","Frankie","Gabi","Harper","Jordan","Kit"],"i":[1,2,3,4,5,6,7,8,9,10],"t":[1756731600,1756732500,1756733400,1756734300,1756735200,1756736100,1756737000,1756737900,1756738800,1756739700,1756740600,1756741500,1756742400,1756743300,1756744200,1756745100,1756746000,1756746900,1756747800,1756748700,1756749600,1756750500,1756751400,1756752300,1756753200,1756754100,1756755000,1756755900,1756756800,1756757700,1756758600,1756759500,1756818000,1756818900,1756819800,1756820700,1756821600,1756822500,1756823400,1756824300,1756825200,1756826100,1756827000,1756827900,1756828800,1756829700,1756830600,1756831500,1756832400,1756833300,1756834200,1756835100,1756836000,1756836900,1756837800,1756838700,1756839600,1756840500,1756841400,1756842300,1756843200,1756844100,1756845000,1756845900,1756904400,1756905300,1756906200,1756907100,1756908000,1756908900,1756909800,1756910700,1756911600,1756912500,1756913400,1756914300,1756915200,1756916100,1756917000,1756917900,1756918800,1756919700,1756920600,1756921500,1756922400,1756923300,1756924200,1756925100,1756926000,1756926900,1756927800,1756928700,1756929600,1756930500,1756931400,1756932300,1756990800,1756991700,1756992600,1756993500,1756994400,1756995300,1756996200,1756997100,1756998000,1756998900,1756999800,1757000700,1757001600,1757002500,1757003400,1757004300,1757005200,1757006100,1757007000,1757007900,1757008800,1757009700,1757010600,1757011500,1757012400,1757013300,1757014200,1757015100,1757016000,1757016900,1757017800,1757018700,1757077200,1757078100,1757079000,1757079900,1757080800,1757081700,1757082600,1757083500,1757084400,1757085300,1757086200,1757087100,1757088000,1757088900,1757089800,1757090700,1757091600,1757092500,1757093400,1757094300,1757095200,1757096100,1757097000,1757097900,1757098800,1757099700,1757100600,1757101500,1757102400,1757103300,1757104200,1757105100],"a":[[5,6],[5,6],[5,6],[5,6],[1,5,6,9],[1,5,6,9],[1,6,9],[1,6,9],[1,6,9],[1,6,9],[1,6,9],[1,6,9],[1,9],[1,9],[1,9],[1,9],[1,9],[1,9],[1,9],[1,9],[1,9],[1,9],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[5,6],[5,6],[5,6],[5,6],[3,6],[3,6],[3,6],[3,6],[1,3,6,9,10],[1,3,6,9,10],[1,3,6,9,10],[1,3,6,9,10],[1,9,10],[1,9,10],[1,9,10],[1,9,10],[1,9,10],[1,9,10],[1,10],[1,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,5,10],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6,9],[3,5,6,9],[3,5,6,9],[3,5,6,9],[1,2,3,4,5,6,9,10],[1,2,3,4,5,6,9,10],[1,2,3,4,5,6,9,10],[1,2,3,4,5,6,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,9,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[5,6],[5,6],[5,6],[5,6],[1,3,5,6],[1,3,6],[1,3,6],[1,3,6],[1,3,4,6,9,10],[1,3,4,6,9,10],[1,3,4,6,9,10],[1,3,4,6,9,10],[1,9,10],[1,9,10],[1,9,10],[1,9,10],[1,9,10],[1,9,10],[1,10],[1,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[1,3,10],[3,10],[3,10],[3,10],[3,10],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3,5,6],[3],[3],[3],[3],[10],[10],[10],[10],[10],[10],[10],[10],[3,10],[3,10],[3,10],[3,10],[3,10],[3,10],[3,10],[3,10]]},{"v":1,"e":"Team Planning","n":["Alex","Blake","Casey","Dana","Ellis","Frankie","Gabi","Harper","Jordan","Kit","Lee","Morgan","Quinn","Riley","Sage","Taylor","Avery","Cameron","Drew","Emery"],"i":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],"t":[279795600,279796500,279797400,279798300,279799200,279800100,279801000,279801900,279802800,279803700,279804600,279805500,279806400,279807300,279808200,279809100,279810000,279810900,279811800,279812700,279813600,279814500,279815400,279816300,279817200,279818100,279819000,279819900,279820800,279821700,279822600,279823500,279824400,279825300,279826200,279827100,279828000,279828900,279829800,279830700,279882000,279882900,279883800,279884700,279885600,279886500,279887400,279888300,279889200,279890100,279891000,279891900,279892800,279893700,279894600,279895500,279896400,279897300,279898200,279899100,279900000,279900900,279901800,279902700,279903600,279904500,279905400,279906300,279907200,279908100,279909000,279909900,279910800,279911700,279912600,279913500,279914400,279915300,279916200,279917100,279968400,279969300,279970200,279971100,279972000,279972900,279973800,279974700,279975600,279976500,279977400,279978300,279979200,279980100,279981000,279981900,279982800,279983700,279984600,279985500,279986400,279987300,279988200,279989100,279990000,279990900,279991800,279992700,279993600,279994500,279995400,279996300,279997200,279998100,279999000,279999900,280000800,280001700,280002600,280003500,280054800,280055700,280056600,280057500,280058400,280059300,280060200,280061100,280062000,280062900,280063800,280064700,280065600,280066500,280067400,280068300,280069200,280070100,280071000,280071900,280072800,280073700,280074600,280075500,280076400,280077300,280078200,280079100,280080000,280080900,280081800,280082700,280083600,280084500,280085400,280086300,280087200,280088100,280089000,280089900,280141200,280142100,280143000,280143900,280144800,280145700,280146600,280147500,280148400,280149300,280150200,280151100,280152000,280152900,280153800,280154700,280155600,280156500,280157400,280158300,280159200,280160100,280161000,280161900,280162800,280163700,280164600,280165500,280166400,280167300,280168200,280169100,280170000,280170900,280171800,280172700,280173600,280174500,280175400,280176300],"a":[[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13],[1,2,4,5,7,13],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,7,13,14],[1,2,4,7,13,14],[1,2,4,7,13,14],[1,2,4,7,13,14],[2,4,7,13,14,16,19],[2,4,7,13,14,16,19],[2,4,7,13,14,16,19],[2,4,7,13,14,16,19],[2,4,7,13,14,16,19],[2,4,7,13,14,16,19],[2,4,7,10,13,14,16,19],[2,4,7,10,13,14,16,19,20],[4,7,10,14,16,19,20],[4,7,10,14,16,19,20],[4,7,10,14,16,19,20],[4,7,10,14,16,19,20],[2,3,4,7,10,16,18,19,20],[2,3,4,7,10,16,18,19,20],[1,2,3,4,7,10,13,16,18,20],[1,2,3,4,7,10,13,16,18,20],[1,2,3,4,7,13,16,18],[1,2,3,4,7,13,16,18],[1,2,3,4,7,13,16,18],[1,2,3,4,7,13,18],[1,2,3,4,7,13,18],[1,2,3,4,7,13,18],[1,2,3,4,7,13,18],[1,2,3,4,7,13,18],[1,2,4,5,13,14,16,18,19],[1,2,4,5,13,14,16,18,19],[1,2,4,5,13,14,16,18,19],[1,2,4,5,13,14,16,18,19],[1,2,4,5,7,14,16,18,19],[1,2,4,5,7,14,16,18,19],[1,4,5,7,10,14,16,18,19],[1,4,5,7,10,14,16,18,19],[1,4,5,7,10,14,16,18],[1,4,5,7,10,14,16,18],[1,4,5,10,13,14,16,18],[1,4,5,10,13,14,16,18],[1,4,13,14,16,18],[1,4,13,14,16,18],[1,4,7,13,14,16,18],[1,4,7,13,14,16,18],[1,4,7,13,14,16,18],[1,4,7,13,14,16,18],[1,4,7,13,16,18],[1,4,7,13,16,18],[1,4,7,13,16],[1,4,7,13,16],[1,4,7,13,16],[1,4,7,13,16,20],[1,4,6,7,13,16,20],[1,4,6,7,13,16,20],[1,4,6,7,10,13,16,20],[1,4,6,7,10,13,16,20],[1,4,6,7,10,13,16,20],[1,4,6,7,10,13,16,20],[1,4,6,7,10,13,16,20],[1,4,6,7,10,13,16,20],[1,4,7,10,13,14,16],[1,4,7,10,13,14],[1,4,7,10,13,14],[1,4,7,10,13,14],[1,3,4,7,10,13,14],[1,3,4,7,10,13,14],[1,3,4,7,10,13,14],[1,3,4,7,10,13,14],[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13,16],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,5,7,13,14],[1,2,4,5,7,10,13,14],[1,2,4,5,7,10,13,14],[2,4,5,7,10,13,14],[2,4,5,7,10,13,14],[4,5,7,10,13,14],[4,5,7,10,14],[3,4,7,10,14],[3,4,7,10,14],[1,3,4,7,10,14,16],[1,3,4,7,10,14,16],[1,3,4,7,10,14,16,18],[1,3,4,7,10,13,14,16,18],[1,3,4,7,10,13,14,16,18],[1,3,4,7,10,13,14,16,18,19],[1,4,7,10,13,14,16,18,19],[1,4,7,10,13,14,16,18,19],[1,4,7,10,13,14,16,18,19],[1,4,7,10,13,14,18,19],[1,2,4,6,7,10,13,14,19],[1,2,4,6,7,10,13,14,19],[1,2,4,6,7,10,13,14,19],[1,2,4,6,7,10,13,14,19],[1,2,4,6,7,13,14,19],[1,2,4,6,7,13,14,19],[1,2,4,7,13,14],[1,2,4,7,13,14],[1,2,4,7,13,14],[1,2,4,7,13,14],[1,2,4,7,13,14],[1,2,4,7,13,14],[2,4,5,7,13,14],[2,4,5,7,13,14,16],[2,4,5,7,13,14,16],[2,4,5,7,13,14,16],[2,4,5,13,14,16],[2,4,5,13,14,16],[4,5,6,10,13,14,16],[4,5,6,10,13,14,16],[4,5,6,10,13,14,16,18],[4,5,6,10,13,14,16,18],[1,4,5,6,7,10,13,14,16,18],[1,4,5,6,7,10,13,14,16,18],[1,4,7,13,14,16,18],[1,4,7,13,14,16,18],[1,3,4,7,13,14,16,18],[1,3,4,7,13,14,16,18],[2,3,4,7,13,14,16],[2,3,4,7,13,14,16],[2,3,4,7,13,14,16],[2,3,4,7,13,14,16],[2,4,7,13,14,16],[2,4,7,13,14,16],[2,4,7,13,14,16],[2,4,7,13,14,16,20],[1,2,3,4,7,13,14,16,20],[1,2,3,4,7,13,14,16,20],[1,2,3,4,7,10,13,14,16,20],[1,2,3,4,7,10,13,14,16,20],[1,2,3,4,6,7,10,13,14,15,16,20],[1,2,3,4,6,7,10,13,14,15,16,20],[1,2,3,4,6,7,10,13,14,15,16,20],[1,2,3,4,6,7,10,13,14,15,16,20],[1,2,4,7,10,13,14,16],[1,2,4,7,10,13,14],[1,2,4,7,10,13,14],[1,2,4,7,10,13,14],[1,2,4,7,10,13,14],[1,2,4,7,10,13,14],[1,2,4,7,10,13,14],[1,2,4,7,10,13,14],[1,2,5,7,13,14,18],[1,2,5,7,13,14,18],[1,2,5,6,7,13,14,18],[1,2,5,6,7,13,14,18],[1,2,5,6,13,14,18],[1,2,5,6,13,14,18],[1,5,13,14,18],[1,5,13,14,18],[1,5,13,14],[1,5,13,14],[1,5,13,14],[1,13],[1,7,20],[1,7,20],[1,7,10,20],[1,7,10,20],[1,7,10,20],[1,7,10,20],[1,7,10,13,20],[1,7,10,13,20],[1,7,10,13,16],[1,7,10,13,16,19],[1,7,10,13,16,19],[1,2,7,10,13,16,19],[1,2,7,10,13,16,19],[1,2,7,10,13,16,19],[1,2,7,10,13,16,19],[1,2,7,10,13,16,19],[1,2,7,10,13,19],[1,2,7,10,13,19],[1,2,7,10,13,19],[1,2,7,10,13,19],[1,2,7,10,13,19],[1,2,7,10,13,19],[1,2,7,10,13,19],[1,2,7,10,13,19],[1,2,3,7,10,13,19],[1,2,3,7,10,13,19],[1,2,3,7,10,13,19],[1,2,3,7,10,13,19]]}];

function loadDemo() {
  const demo = DEMOS[Math.floor(Math.random() * DEMOS.length)];
  const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(demo))));
  location.hash = encoded;
}

init();
</script>
</body>
</html>
