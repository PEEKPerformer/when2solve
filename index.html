<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>When2Solve â€” When2Meet Optimizer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,300&family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  RESET & ROOT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg-deep:#0a0e17;--bg-card:#111827;--bg-cell:#1a2235;--bg-hover:#243049;
  --border:#1e293b;--border-light:#334155;
  --text-primary:#e2e8f0;--text-secondary:#94a3b8;--text-muted:#64748b;
  --accent:#22d3ee;--accent-dim:rgba(34,211,238,0.15);
  --heat-0:#111827;--heat-1:#1e1a2e;--heat-2:#2d1f3d;--heat-3:#4c1d6e;
  --heat-4:#7c2d8e;--heat-5:#b83a6a;--heat-6:#e04842;--heat-7:#f59e0b;--heat-8:#fbbf24;
  --p0:#f472b6;--p1:#60a5fa;--p2:#a78bfa;--p3:#34d399;
  --p4:#fbbf24;--p5:#fb923c;--p6:#2dd4bf;--p7:#f87171;
}
html{font-size:16px}
body{font-family:'DM Sans',system-ui,sans-serif;background:var(--bg-deep);color:var(--text-primary);min-height:100vh;overflow-x:hidden}
body::before{content:'';position:fixed;inset:0;background:radial-gradient(ellipse at 25% 15%,rgba(124,45,142,0.07)0%,transparent 55%),radial-gradient(ellipse at 75% 85%,rgba(6,182,212,0.04)0%,transparent 55%);pointer-events:none;z-index:0}
::selection{background:rgba(34,211,238,0.3);color:#fff}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  LANDING PAGE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
.landing{position:relative;z-index:1;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:2rem;text-align:center}
.landing-inner{max-width:680px;animation:fadeUp .8s ease-out}
.logo{font-family:'JetBrains Mono',monospace;font-size:.8rem;letter-spacing:.25em;text-transform:uppercase;color:var(--accent);margin-bottom:1rem;opacity:.8}
.landing h1{font-size:clamp(2.4rem,6vw,3.8rem);font-weight:700;letter-spacing:-.04em;line-height:1.1;margin-bottom:.6rem}
.landing h1 .grad{background:linear-gradient(135deg,#e2e8f0 0%,var(--accent) 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.landing .tagline{font-size:1.1rem;color:var(--text-secondary);font-weight:300;margin-bottom:3rem;font-style:italic}

.steps{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:1.2rem;margin-bottom:3rem;text-align:left}
.step{background:var(--bg-card);border:1px solid var(--border);border-radius:14px;padding:1.3rem;position:relative;overflow:hidden;transition:border-color .3s,transform .3s}
.step:hover{border-color:var(--border-light);transform:translateY(-2px)}
.step::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg,var(--accent),transparent);opacity:.4}
.step-num{font-family:'JetBrains Mono',monospace;font-size:.72rem;color:var(--accent);letter-spacing:.15em;text-transform:uppercase;margin-bottom:.5rem;font-weight:600}
.step-title{font-weight:600;font-size:1.05rem;margin-bottom:.35rem}
.step-desc{font-size:.88rem;color:var(--text-muted);line-height:1.5}

/* Bookmarklet button */
.bm-container{margin-bottom:2rem}
.bm-label{font-family:'JetBrains Mono',monospace;font-size:.72rem;color:var(--text-muted);letter-spacing:.1em;text-transform:uppercase;margin-bottom:.8rem}
.bm-button{display:inline-block;padding:.85rem 2rem;background:linear-gradient(145deg,#1a2a40,#0f1a2a);border:1.5px solid var(--accent);border-radius:10px;color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:.85rem;font-weight:600;letter-spacing:.04em;text-decoration:none;cursor:grab;transition:all .3s ease;box-shadow:0 0 20px rgba(34,211,238,0.1),0 4px 20px rgba(0,0,0,0.4),inset 0 1px 0 rgba(255,255,255,0.05);position:relative;user-select:none}
.bm-button:hover{transform:translateY(-3px);box-shadow:0 0 35px rgba(34,211,238,0.2),0 8px 30px rgba(0,0,0,0.5),inset 0 1px 0 rgba(255,255,255,0.08);background:linear-gradient(145deg,#1e3350,#132238)}
.bm-button:active{cursor:grabbing;transform:translateY(-1px)}
.bm-button::before{content:'';position:absolute;inset:-1px;border-radius:11px;background:linear-gradient(135deg,rgba(34,211,238,0.2),transparent 60%);z-index:-1;opacity:0;transition:opacity .3s}
.bm-button:hover::before{opacity:1}
.bm-hint{font-size:.82rem;color:var(--text-muted);margin-top:.8rem}

.landing-footer{font-size:.82rem;color:var(--text-muted);margin-top:2rem;line-height:1.6}
.landing-footer a{color:var(--accent);text-decoration:none}

/* Demo button */
.demo-btn{display:inline-block;margin-top:1rem;padding:.6rem 1.5rem;background:transparent;border:1px solid var(--border-light);border-radius:8px;color:var(--text-secondary);font-size:.9rem;font-weight:500;cursor:pointer;transition:all .2s;font-family:'DM Sans',sans-serif}
.demo-btn:hover{border-color:var(--text-muted);color:var(--text-primary);background:rgba(255,255,255,0.02)}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  SOLVER VIEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
.solver{display:none;position:relative;z-index:1;max-width:1100px;margin:0 auto;padding:1.2rem}
.solver.active{display:block}
.landing.hidden{display:none}

.topbar{display:flex;align-items:center;justify-content:space-between;margin-bottom:1rem;flex-wrap:wrap;gap:.7rem;animation:fadeDown .5s ease-out;padding:.7rem 1rem;background:var(--bg-card);border:1px solid var(--border);border-radius:12px}
.topbar-left{display:flex;align-items:center;gap:.8rem}
.topbar-brand{font-family:'JetBrains Mono',monospace;font-size:.85rem;font-weight:600;color:var(--accent);letter-spacing:.06em;cursor:pointer;transition:opacity .2s}
.topbar-brand:hover{opacity:.7}
.topbar-event{font-size:.85rem;color:var(--text-muted);max-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.topbar-center{display:flex;align-items:center;gap:1rem;flex-wrap:wrap}
.topbar-right{display:flex;align-items:center;gap:.6rem}
.topbar-badge{font-family:'JetBrains Mono',monospace;font-size:.72rem;padding:.3rem .65rem;border-radius:6px;background:rgba(34,211,238,0.08);border:1px solid rgba(34,211,238,0.15);color:var(--accent);letter-spacing:.04em}
.ctrl-label{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:.1em;white-space:nowrap}
.seg-group{display:flex;align-items:center;gap:.45rem}
.seg-btns{display:flex;background:var(--bg-deep);border-radius:8px;padding:3px;border:1px solid var(--border);overflow:hidden}
.seg-btn{font-family:'JetBrains Mono',monospace;font-size:.75rem;padding:.35rem .65rem;color:var(--text-muted);cursor:pointer;transition:all .2s;white-space:nowrap;user-select:none;border-radius:5px;text-align:center}
.seg-btn:hover{color:var(--text-secondary)}
.seg-btn.active{background:var(--bg-hover);color:var(--text-primary)}
.topbar-divider{width:1px;height:24px;background:var(--border);margin:0 .2rem}
@media(max-width:720px){.topbar{flex-direction:column;align-items:stretch;gap:.5rem}.topbar-center{justify-content:center}.topbar-right{justify-content:flex-end}}

.blocked-bar{display:flex;align-items:center;gap:.6rem;padding:.5rem .8rem;margin-bottom:.5rem;flex-wrap:wrap}
.blocked-list{display:flex;flex-wrap:wrap;gap:4px;align-items:center}
.blocked-chip{font-family:'JetBrains Mono',monospace;font-size:.7rem;padding:3px 8px;border-radius:5px;background:rgba(239,68,68,0.1);color:#ef4444;border:1px solid rgba(239,68,68,0.2);display:flex;align-items:center;gap:4px;cursor:pointer;transition:all .2s}
.blocked-chip:hover{background:rgba(239,68,68,0.2)}
.blocked-chip .x{font-size:.8rem;line-height:1}

/*â”€â”€ Team bar â”€â”€*/
.team-bar{display:flex;flex-wrap:wrap;align-items:center;gap:.5rem;padding:.75rem 1rem;background:var(--bg-card);border:1px solid var(--border);border-radius:12px;margin-bottom:1rem;animation:fadeUp .5s ease-out .2s both}
.team-label{font-family:'JetBrains Mono',monospace;font-size:.7rem;text-transform:uppercase;letter-spacing:.1em;color:var(--text-muted);margin-right:.3rem}
.team-chip{display:inline-flex;align-items:center;gap:6px;padding:5px 12px;border-radius:20px;background:rgba(255,255,255,0.02);border:1px solid var(--border);font-size:.82rem;cursor:pointer;transition:all .2s;user-select:none}
.team-chip:hover{border-color:var(--border-light);background:var(--bg-hover)}
.team-chip.required{border-color:rgba(34,211,238,0.3);background:rgba(34,211,238,0.06)}
.chip-dot{width:9px;height:9px;border-radius:50%;flex-shrink:0}
.chip-hours{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted)}
.chip-req{font-family:'JetBrains Mono',monospace;font-size:.52rem;text-transform:uppercase;letter-spacing:.06em;color:var(--accent);background:var(--accent-dim);padding:2px 5px;border-radius:3px}
.team-stats{font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted);margin-left:auto}

/*â”€â”€ Decision cards â”€â”€*/
.decisions{margin-bottom:1.2rem}
.section-head{font-family:'JetBrains Mono',monospace;font-size:.72rem;text-transform:uppercase;letter-spacing:.12em;color:var(--text-muted);margin-bottom:.8rem;margin-top:1.2rem;display:flex;align-items:center;gap:.6rem}
.section-head::after{content:'';flex:1;height:1px;background:var(--border)}

.options-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(210px,1fr));gap:.8rem;margin-bottom:1rem}
.option-card{background:var(--bg-card);border:1px solid var(--border);border-radius:12px;padding:1.2rem;position:relative;transition:all .3s;animation:fadeUp .5s ease-out both}
.option-card:hover{border-color:var(--border-light);transform:translateY(-2px)}
.option-card.best{border-color:rgba(34,211,238,0.3);box-shadow:0 0 24px rgba(34,211,238,0.06)}
.card-badge{font-family:'JetBrains Mono',monospace;font-size:.6rem;text-transform:uppercase;letter-spacing:.1em;color:var(--accent);margin-bottom:.4rem}
.card-day{font-size:1.15rem;font-weight:600;color:var(--text-primary);margin-bottom:.15rem}
.card-time{font-family:'JetBrains Mono',monospace;font-size:.82rem;color:var(--text-secondary);margin-bottom:.6rem}
.att-dots{display:flex;gap:5px;margin-bottom:.4rem;flex-wrap:wrap}
.att-dot{width:12px;height:12px;border-radius:50%;transition:all .2s}
.att-dot.absent{background:transparent!important;opacity:.3}
.card-count{font-family:'JetBrains Mono',monospace;font-size:.75rem;color:var(--text-secondary);margin-bottom:.25rem}
.card-missing{font-size:.75rem;color:var(--text-muted);font-style:italic;margin-bottom:.7rem;min-height:1.2em;line-height:1.4}
.card-missing.card-all{color:var(--accent);font-style:normal;font-weight:500}
.card-dismiss{background:none;border:1px solid var(--border);border-radius:6px;color:var(--text-muted);font-size:.72rem;padding:.35rem .7rem;cursor:pointer;transition:all .2s;width:100%;font-family:'DM Sans',sans-serif}
.card-dismiss:hover{color:#ef4444;border-color:rgba(239,68,68,0.3);background:rgba(239,68,68,0.04)}

/*â”€â”€ Plan cards â”€â”€*/
.plan-card{background:var(--bg-card);border:1px solid var(--border);border-radius:12px;padding:1.4rem;position:relative;margin-bottom:.8rem;animation:fadeUp .5s ease-out both}
.plan-card.best{border-color:rgba(34,211,238,0.3);box-shadow:0 0 24px rgba(34,211,238,0.06)}
.plan-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:.9rem}
.plan-label{font-family:'JetBrains Mono',monospace;font-size:.72rem;text-transform:uppercase;letter-spacing:.08em;color:var(--accent);font-weight:600}
.plan-coverage-badge{font-family:'JetBrains Mono',monospace;font-size:.72rem;padding:.25rem .7rem;border-radius:5px;background:rgba(34,211,238,0.08);color:var(--accent);border:1px solid rgba(34,211,238,0.15)}
.plan-meetings{display:grid;grid-template-columns:1fr auto 1fr;gap:.6rem;align-items:start;margin-bottom:.7rem}
.plan-meeting{background:rgba(255,255,255,0.015);border:1px solid var(--border);border-radius:8px;padding:.85rem}
.plan-connector{font-size:.85rem;color:var(--text-muted);font-weight:700;display:flex;align-items:center;justify-content:center;padding-top:1.4rem}
.plan-breakdown{font-size:.75rem;color:var(--text-muted);line-height:1.6;margin-bottom:.4rem}
.plan-breakdown span{font-weight:500;color:var(--text-secondary)}
.plan-dismiss{position:absolute;top:.9rem;right:.9rem;background:none;border:none;color:var(--text-muted);font-size:1.1rem;cursor:pointer;padding:4px 8px;border-radius:4px;transition:all .2s;line-height:1}
.plan-dismiss:hover{color:#ef4444;background:rgba(239,68,68,0.06)}
@media(max-width:580px){.plan-meetings{grid-template-columns:1fr}.plan-connector{padding:0;font-size:.75rem}}

/*â”€â”€ Insights â”€â”€*/
.insights-panel{background:var(--bg-card);border:1px solid var(--border);border-radius:12px;padding:1rem 1.2rem;margin-bottom:1rem}
.insight-item{display:flex;align-items:baseline;gap:.6rem;padding:.4rem 0;font-size:.85rem;color:var(--text-secondary);line-height:1.5;border-bottom:1px solid rgba(255,255,255,0.03)}
.insight-item:last-child{border-bottom:none}
.insight-icon{flex-shrink:0;width:1.2em;text-align:center;font-size:.9rem}
.insight-item strong{color:var(--text-primary);font-weight:600}
.insight-item .hl{color:#22d3ee}
.insight-item .warn{color:#fbbf24}
.insight-item .soft{color:var(--text-muted);font-size:.75rem}

/*â”€â”€ Heatmap (collapsible) â”€â”€*/
.heatmap-toggle{display:flex;align-items:center;gap:.5rem;padding:.6rem 0;font-family:'JetBrains Mono',monospace;font-size:.78rem;color:var(--text-muted);cursor:pointer;transition:color .2s;user-select:none}
.heatmap-toggle:hover{color:var(--text-secondary)}
.heatmap-section{overflow:hidden;transition:all .3s}
.heatmap-section.collapsed{display:none}
.heatmap-inner{display:grid;grid-template-columns:1fr 220px;gap:1rem;align-items:start}
@media(max-width:900px){.heatmap-inner{grid-template-columns:1fr}}
.heatmap-panel{background:var(--bg-card);border:1px solid var(--border);border-radius:14px;padding:1.2rem;overflow-x:auto}
.heatmap-wrapper{min-width:640px;position:relative}
.heatmap-grid{display:grid;gap:0;position:relative}
.day-header{text-align:center;padding:.5rem .2rem;font-weight:600;font-size:.88rem;letter-spacing:.03em;color:var(--text-secondary);border-bottom:1px solid var(--border)}
.time-header{border-bottom:1px solid var(--border);display:flex;align-items:flex-end;justify-content:center;padding-bottom:.4rem;font-family:'JetBrains Mono',monospace;font-size:.65rem;color:var(--text-muted);letter-spacing:.08em;text-transform:uppercase}
.time-label{font-family:'JetBrains Mono',monospace;font-size:.7rem;color:var(--text-muted);display:flex;align-items:center;justify-content:flex-end;padding-right:6px;height:22px;user-select:none}
.time-label.hour{color:var(--text-secondary);font-weight:500}
.cell{height:22px;border:1px solid rgba(30,41,59,0.4);cursor:pointer;transition:all .12s;position:relative}
.cell:hover{transform:scaleY(1.4);z-index:5;border-color:rgba(255,255,255,0.15);box-shadow:0 0 10px rgba(255,255,255,0.04)}
.cell.h0{background:var(--heat-0)}.cell.h1{background:var(--heat-1)}.cell.h2{background:var(--heat-2)}
.cell.h3{background:var(--heat-3)}.cell.h4{background:var(--heat-4)}.cell.h5{background:var(--heat-5)}
.cell.h6{background:var(--heat-6)}.cell.h7{background:var(--heat-7)}.cell.h8{background:var(--heat-8)}
.cell.h9{background:#fcd34d}.cell.h10{background:#fde68a}
.cell.person-on{box-shadow:inset 0 0 8px rgba(255,255,255,0.15)}
.cell.person-off{background:var(--heat-0)!important;opacity:.35}
.cell.blocked::before{content:'';position:absolute;inset:0;background:repeating-linear-gradient(-45deg,transparent,transparent 3px,rgba(239,68,68,0.15) 3px,rgba(239,68,68,0.15) 4px);pointer-events:none;z-index:1}

.sol-outline{position:absolute;border:2px solid var(--accent);border-radius:4px;pointer-events:none;z-index:10;animation:solPulse 2.5s ease-in-out infinite;box-shadow:0 0 18px rgba(34,211,238,0.15),inset 0 0 18px rgba(34,211,238,0.04)}
.sol-outline .sol-tag{position:absolute;top:-22px;left:50%;transform:translateX(-50%);font-family:'JetBrains Mono',monospace;font-size:.68rem;font-weight:600;color:var(--accent);white-space:nowrap;letter-spacing:.04em;text-shadow:0 0 10px rgba(34,211,238,0.4)}
@keyframes solPulse{0%,100%{border-color:rgba(34,211,238,0.75);box-shadow:0 0 18px rgba(34,211,238,0.15),inset 0 0 18px rgba(34,211,238,0.04)}50%{border-color:rgba(34,211,238,0.35);box-shadow:0 0 32px rgba(34,211,238,0.3),inset 0 0 22px rgba(34,211,238,0.08)}}

.heat-legend{display:flex;align-items:center;justify-content:center;gap:1px;margin-top:.8rem;padding-top:.8rem;border-top:1px solid var(--border)}
.heat-legend span{font-family:'JetBrains Mono',monospace;font-size:.68rem;color:var(--text-muted);margin:0 6px}
.hswatch{width:22px;height:12px;border-radius:2px}

.panel{background:var(--bg-card);border:1px solid var(--border);border-radius:14px;padding:1rem}
.panel-title{font-family:'JetBrains Mono',monospace;font-size:.72rem;text-transform:uppercase;letter-spacing:.12em;color:var(--text-muted);margin-bottom:.8rem}
.person-row{display:flex;align-items:center;gap:8px;padding:6px 8px;margin:2px 0;border-radius:7px;cursor:pointer;transition:all .2s;user-select:none;position:relative}
.person-row:hover{background:var(--bg-hover)}
.person-row.active{background:var(--bg-hover)}
.person-row.required::after{content:'REQ';position:absolute;right:7px;top:50%;transform:translateY(-50%);font-family:'JetBrains Mono',monospace;font-size:.55rem;color:var(--accent);letter-spacing:.06em;background:var(--accent-dim);padding:2px 6px;border-radius:3px}
.pdot{width:10px;height:10px;border-radius:50%;flex-shrink:0;transition:transform .2s,box-shadow .2s}
.person-row.active .pdot{transform:scale(1.5);box-shadow:0 0 8px currentColor}
.pname{font-size:.9rem;font-weight:500;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.phours{font-family:'JetBrains Mono',monospace;font-size:.75rem;color:var(--text-muted)}
.pbar-track{position:absolute;bottom:0;left:0;right:0;height:2px;background:rgba(255,255,255,0.03);border-radius:1px;overflow:hidden}
.pbar-fill{height:100%;border-radius:1px;transform-origin:left;animation:barIn .8s ease-out forwards}
@keyframes barIn{from{transform:scaleX(0)}to{transform:scaleX(1)}}
.clear-btn{display:none;margin-top:.5rem;padding:.4rem;background:rgba(239,68,68,0.06);border:1px solid rgba(239,68,68,0.15);border-radius:6px;color:#ef4444;font-size:.78rem;font-weight:500;cursor:pointer;text-align:center;transition:all .2s;font-family:'DM Sans',sans-serif}
.clear-btn:hover{background:rgba(239,68,68,0.12)}
.clear-btn.show{display:block}

.dismissed-info{text-align:center;margin-top:.7rem;font-size:.75rem;color:var(--text-muted)}
.dismissed-info a{color:var(--accent);cursor:pointer;text-decoration:none}
.dismissed-info a:hover{text-decoration:underline}

/*â”€â”€ Tooltip â”€â”€*/
.tooltip{position:fixed;background:#1e293b;border:1px solid var(--border-light);border-radius:10px;padding:.7rem .9rem;pointer-events:none;z-index:200;opacity:0;transition:opacity .12s;max-width:280px;box-shadow:0 8px 32px rgba(0,0,0,0.5)}
.tooltip.vis{opacity:1}
.tt-time{font-family:'JetBrains Mono',monospace;font-size:.78rem;color:var(--accent);margin-bottom:.35rem;font-weight:500}
.tt-count{font-size:.82rem;color:var(--text-secondary);margin-bottom:.4rem;font-weight:500}
.tt-chips{display:flex;flex-wrap:wrap;gap:3px}
.tt-chip{font-size:.72rem;padding:2px 7px;border-radius:3px;font-weight:500;color:#fff}
.tt-absent{margin-top:.35rem;font-size:.7rem;color:var(--text-muted);font-style:italic}
.tt-block-hint{margin-top:.35rem;font-family:'JetBrains Mono',monospace;font-size:.65rem;color:#ef4444;letter-spacing:.03em}

/*â”€â”€ Animations â”€â”€*/
@keyframes fadeUp{from{opacity:0;transform:translateY(14px)}to{opacity:1;transform:translateY(0)}}
@keyframes fadeDown{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}

</style>
</head>
<body>

<!-- â•â•â• LANDING â•â•â• -->
<div class="landing" id="landing">
<div class="landing-inner">
  <div class="logo">When2Solve</div>
  <h1><span class="grad">When2Meet finds times.<br>We find answers.</span></h1>
  <p class="tagline">A client-side optimizer that turns your When2Meet into actionable meeting recommendations â€” with constraints, multi-meeting coverage, and zero servers.</p>

  <div class="steps">
    <div class="step">
      <div class="step-num">Step 01</div>
      <div class="step-title">Grab the bookmarklet</div>
      <div class="step-desc">Drag the button below into your browser's bookmark bar. It's a tiny script that reads When2Meet data.</div>
    </div>
    <div class="step">
      <div class="step-num">Step 02</div>
      <div class="step-title">Visit your When2Meet</div>
      <div class="step-desc">Open any When2Meet event page where participants have filled in their availability.</div>
    </div>
    <div class="step">
      <div class="step-num">Step 03</div>
      <div class="step-title">Click &amp; solve</div>
      <div class="step-desc">Click the bookmarklet. It extracts the data and launches When2Solve with instant recommendations.</div>
    </div>
  </div>

  <div class="bm-container">
    <div class="bm-label">Drag this to your bookmark bar</div>
    <a class="bm-button" id="bookmarklet" href="#">âš¡ When2Solve</a>
    <div class="bm-hint">Works on any When2Meet event Â· No data leaves your browser</div>
  </div>

  <button class="demo-btn" onclick="loadDemo()">Try with demo data</button>

  <div class="landing-footer">
    Built with no backend Â· Runs entirely in your browser Â· <a href="https://github.com">View on GitHub</a>
  </div>
</div>
</div>

<!-- â•â•â• SOLVER â•â•â• -->
<div class="solver" id="solver">
  <div class="topbar">
    <div class="topbar-left">
      <div class="topbar-brand" onclick="goHome()">WHEN2SOLVE</div>
      <div class="topbar-event" id="eventInfo"></div>
    </div>
    <div class="topbar-center">
      <div class="seg-group">
        <span class="ctrl-label">Duration</span>
        <div class="seg-btns" id="ctrlDuration">
          <div class="seg-btn" data-val="2">30m</div>
          <div class="seg-btn" data-val="3">45m</div>
          <div class="seg-btn active" data-val="4">1h</div>
          <div class="seg-btn" data-val="5">1Â¼h</div>
          <div class="seg-btn" data-val="6">1Â½h</div>
        </div>
      </div>
      <div class="topbar-divider"></div>
      <div class="seg-group">
        <span class="ctrl-label">Meetings</span>
        <div class="seg-btns" id="ctrlMeetings">
          <div class="seg-btn active" data-val="0">Auto</div>
          <div class="seg-btn" data-val="1">1</div>
          <div class="seg-btn" data-val="2">2</div>
        </div>
      </div>
    </div>
    <div class="topbar-right">
      <div class="topbar-badge" id="participantBadge"></div>
    </div>
  </div>

  <div id="teamBar" class="team-bar"></div>
  <div id="decisions" class="decisions"></div>

  <div class="heatmap-toggle" id="heatmapToggle" onclick="toggleHeatmap()">&#9656; Explore raw availability</div>
  <div class="heatmap-section collapsed" id="heatmapSection">
    <div class="blocked-bar" id="blockedBar">
      <span class="ctrl-label">Blocked</span>
      <div class="blocked-list" id="blockedList">
        <span style="font-size:.6rem;color:var(--text-muted)">Shift+click cells below</span>
      </div>
    </div>
    <div class="heatmap-inner">
      <div class="heatmap-panel">
        <div class="heatmap-wrapper" id="heatmapWrapper">
          <div class="heatmap-grid" id="grid"></div>
        </div>
        <div class="heat-legend" id="legend"></div>
      </div>
      <div class="panel">
        <div class="panel-title">Click to filter Â· right-click to require</div>
        <div id="peopleList"></div>
        <div class="clear-btn" id="clearBtn" onclick="clearFilter()">&#10005; Clear filter</div>
      </div>
    </div>
  </div>
</div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip">
  <div class="tt-time" id="ttTime"></div>
  <div class="tt-count" id="ttCount"></div>
  <div class="tt-chips" id="ttChips"></div>
  <div class="tt-absent" id="ttAbsent"></div>
  <div class="tt-block-hint" id="ttBlockHint"></div>
</div>

<script>
/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
let STATE = {
  names: [], ids: [], available: [], times: [],
  // derived
  days: [], dayNames: [], dayMap: {}, timeLabels: [], slots: [],
  // constraints
  required: new Set(),
  blocked: new Set(),
  activePerson: null,
  // config
  numPeople: 0,
  // solution state
  dismissed: new Set(),
  currentResults: null,
  heatmapOpen: false,
};

const PCOLORS = ['#f472b6','#60a5fa','#a78bfa','#34d399','#fbbf24','#fb923c','#2dd4bf','#f87171',
                 '#c084fc','#4ade80','#fca5a5','#67e8f9','#fde047','#d946ef','#a3e635','#fb7185'];
const DAY_LABELS = {0:'Sun',1:'Mon',2:'Tue',3:'Wed',4:'Thu',5:'Fri',6:'Sat'};
const BASE_URL = location.href.split('#')[0];

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  BOOKMARKLET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
function setupBookmarklet() {
  const code = `javascript:void(function(){if(typeof PeopleNames==='undefined'){alert('Open a When2Meet event page first!');return;}try{var d=JSON.stringify({n:PeopleNames,i:PeopleIDs,a:AvailableAtSlot,t:TimeOfSlot});var e=btoa(unescape(encodeURIComponent(d)));window.location='${BASE_URL}#'+e;}catch(x){alert('Error: '+x.message);}})()`;
  const el = document.getElementById('bookmarklet');
  el.href = code;
  el.addEventListener('click', function(e) {
    e.preventDefault();
    alert('Drag this button to your bookmark bar!\\nThen visit a When2Meet page and click it.');
  });
}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  DATA DECODE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
function decodeHash() {
  const hash = location.hash.slice(1);
  if (!hash) return null;
  try {
    const json = decodeURIComponent(escape(atob(hash)));
    const d = JSON.parse(json);
    if (!d.n || !d.i || !d.a || !d.t) return null;
    return d;
  } catch(e) {
    console.error('Decode error:', e);
    return null;
  }
}

function processData(raw) {
  STATE.names = raw.n;
  STATE.ids = raw.i;
  STATE.available = raw.a;
  STATE.times = raw.t;
  STATE.numPeople = raw.n.length;
  STATE.required = new Set();
  STATE.blocked = new Set();
  STATE.activePerson = null;

  // Build idâ†’name map
  const idMap = {};
  for (let i = 0; i < STATE.numPeople; i++) idMap[STATE.ids[i]] = STATE.names[i];

  // Parse timestamps (When2Meet uses UTC time as local time, fake 1978 dates)
  // Group by day-of-week
  const daySlots = {};
  const allSlots = [];

  for (let i = 0; i < STATE.times.length; i++) {
    const ts = STATE.times[i];
    const dt = new Date(ts * 1000);
    const utcDay = dt.getUTCDay();
    const utcH = dt.getUTCHours();
    const utcM = dt.getUTCMinutes();
    const dayKey = dt.toISOString().slice(0,10); // unique date key

    if (!daySlots[dayKey]) daySlots[dayKey] = { day: utcDay, date: dayKey, slots: [] };

    const availNames = [];
    const availIds = STATE.available[i] || [];
    for (const pid of availIds) {
      if (idMap[pid]) availNames.push(idMap[pid]);
    }

    const slotObj = {
      idx: i, h: utcH, m: utcM, day: utcDay, dayKey,
      available: new Set(availNames),
      label: formatTime(utcH, utcM),
      isHour: utcM === 0,
    };
    daySlots[dayKey].slots.push(slotObj);
    allSlots.push(slotObj);
  }

  // Sort days
  const sortedDayKeys = Object.keys(daySlots).sort();
  STATE.days = sortedDayKeys;
  STATE.dayNames = sortedDayKeys.map(k => DAY_LABELS[daySlots[k].day] || k);
  STATE.dayMap = daySlots;
  STATE.slots = allSlots;

  // Unique time labels (from first day)
  STATE.timeLabels = daySlots[sortedDayKeys[0]].slots.map(s => ({
    label: s.label, h: s.h, m: s.m, isHour: s.isHour
  }));
}

function formatTime(h, m) {
  const ampm = h >= 12 ? 'PM' : 'AM';
  const h12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
  return `${h12}:${String(m).padStart(2,'0')} ${ampm}`;
}

function shortTime(h, m) {
  const ampm = h >= 12 ? 'p' : 'a';
  const h12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
  return m === 0 ? `${h12}${ampm}` : `${h12}:${String(m).padStart(2,'0')}${ampm}`;
}

function pcolor(name) {
  const idx = STATE.names.indexOf(name);
  return PCOLORS[idx % PCOLORS.length];
}

function shortName(name) {
  if (name.length <= 10) return name;
  const parts = name.split(' ');
  return parts[0];
}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  SOLVER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
function windowsOverlap(a, b) {
  if (a.dayKey !== b.dayKey) return false;
  const aS = a.startH * 60 + a.startM;
  const aE = a.endH * 60 + a.endM;
  const bS = b.startH * 60 + b.startM;
  const bE = b.endH * 60 + b.endM;
  return aS < bE && bS < aE;
}

function solve() {
  const duration = parseInt(document.getElementById('ctrlDuration').querySelector('.seg-btn.active').dataset.val);
  const meetingsPref = parseInt(document.getElementById('ctrlMeetings').querySelector('.seg-btn.active').dataset.val);
  const required = STATE.required;
  const blocked = STATE.blocked;
  const allNames = new Set(STATE.names);

  // Build windows per day
  const windows = [];
  for (const dayKey of STATE.days) {
    const daySlots = STATE.dayMap[dayKey].slots;
    for (let i = 0; i <= daySlots.length - duration; i++) {
      const windowSlots = daySlots.slice(i, i + duration);
      // Check contiguous (15-min gaps)
      let contiguous = true;
      for (let j = 1; j < windowSlots.length; j++) {
        const diff = (windowSlots[j].h * 60 + windowSlots[j].m) - (windowSlots[j-1].h * 60 + windowSlots[j-1].m);
        if (diff !== 15) { contiguous = false; break; }
      }
      if (!contiguous) continue;

      // Check no blocked slots
      const slotKeys = windowSlots.map(s => `${s.dayKey}:${s.h}:${s.m}`);
      if (slotKeys.some(k => blocked.has(k))) continue;

      // Intersect availability across window
      let common = new Set(windowSlots[0].available);
      for (let j = 1; j < windowSlots.length; j++) {
        common = new Set([...common].filter(n => windowSlots[j].available.has(n)));
      }

      // Check required attendees
      let reqMet = true;
      for (const r of required) {
        if (!common.has(r)) { reqMet = false; break; }
      }
      if (!reqMet) continue;

      const endSlot = windowSlots[windowSlots.length - 1];
      const endM = endSlot.m + 15;
      const endH = endSlot.h + Math.floor(endM / 60);

      const key = `${dayKey}:${windowSlots[0].h}:${windowSlots[0].m}`;
      windows.push({
        key,
        dayKey, day: windowSlots[0].day,
        dayName: DAY_LABELS[windowSlots[0].day],
        startH: windowSlots[0].h, startM: windowSlots[0].m,
        endH: endH, endM: endM % 60,
        count: common.size, attendees: common,
        missing: new Set([...allNames].filter(n => !common.has(n))),
        slotKeys,
        startIdx: i,
      });
    }
  }

  windows.sort((a, b) => b.count - a.count || a.startH - b.startH);

  const results = { single: [], pairs: [], coverage: 0, suggestion: null };

  // Deduplicate: only keep the best window per non-overlapping time block
  // This prevents "Not this one" from showing 15-min shifts of the same slot
  const dedupedSingles = [];
  for (const w of windows) {
    if (!dedupedSingles.some(d => windowsOverlap(d, w))) {
      dedupedSingles.push(w);
    }
  }
  results.single = dedupedSingles.slice(0, 12);

  // Check if single meeting covers everyone
  const bestSingle = windows[0];
  const singleCovers = bestSingle && bestSingle.count === STATE.numPeople;

  // Determine meeting count
  let numMeetings = meetingsPref;
  if (numMeetings === 0) {
    numMeetings = singleCovers ? 1 : 2;
  }

  if (numMeetings === 2 && windows.length >= 2) {
    // Find best pairs
    const topN = Math.min(windows.length, 60); // limit search
    let bestPairs = [];
    for (let i = 0; i < topN; i++) {
      for (let j = i + 1; j < topN; j++) {
        const a = windows[i], b = windows[j];
        const union = new Set([...a.attendees, ...b.attendees]);
        const uncovered = [...allNames].filter(n => !union.has(n));
        const score = union.size * 1000 + Math.min(a.count, b.count);
        const diffDay = a.dayKey !== b.dayKey;
        bestPairs.push({
          key: `${a.key}|${b.key}`,
          a, b, union, uncovered, score, diffDay,
          coverage: union.size,
        });
      }
    }
    // Sort: full coverage first, then prefer different days, then balanced attendance
    bestPairs.sort((x, y) => {
      if (y.coverage !== x.coverage) return y.coverage - x.coverage;
      if (x.diffDay !== y.diffDay) return x.diffDay ? -1 : 1;
      return y.score - x.score;
    });
    // Deduplicate pairs: skip if both meetings overlap pairwise with an already-shown pair
    const dedupedPairs = [];
    for (const p of bestPairs) {
      const similar = dedupedPairs.some(d =>
        (windowsOverlap(d.a, p.a) && windowsOverlap(d.b, p.b)) ||
        (windowsOverlap(d.a, p.b) && windowsOverlap(d.b, p.a))
      );
      if (!similar) dedupedPairs.push(p);
    }
    results.pairs = dedupedPairs.slice(0, 10);
  }

  // Coverage
  if (numMeetings === 2 && results.pairs.length > 0) {
    results.coverage = results.pairs[0].coverage;
  } else if (results.single.length > 0) {
    results.coverage = results.single[0].count;
  }

  // Generate suggestion if not full coverage
  if (results.coverage < STATE.numPeople) {
    const bestSol = numMeetings === 2 && results.pairs.length > 0
      ? results.pairs[0] : null;
    if (bestSol) {
      const missing = bestSol.uncovered;
      if (missing.length > 0 && missing.length <= 2) {
        // Check what slot extension would help
        results.suggestion = `${missing.join(' & ')} can't make any combination. Check if they can extend availability on ${bestSol.a.dayName} or ${bestSol.b.dayName}.`;
      }
    }
  }

  results.numMeetings = numMeetings;
  results.windows = windows;
  return results;
}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  RENDER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
let cellEls = [];

function renderGrid() {
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  cellEls = [];

  const nDays = STATE.days.length;
  const nTimes = STATE.timeLabels.length;
  grid.style.gridTemplateColumns = `52px repeat(${nDays}, 1fr)`;

  // Corner + day headers
  const corner = document.createElement('div');
  corner.className = 'time-header';
  grid.appendChild(corner);

  STATE.days.forEach((dk, di) => {
    const dh = document.createElement('div');
    dh.className = 'day-header';
    dh.textContent = STATE.dayNames[di];
    grid.appendChild(dh);
  });

  // Rows
  STATE.timeLabels.forEach((tl, ti) => {
    const label = document.createElement('div');
    label.className = 'time-label' + (tl.isHour ? ' hour' : '');
    label.textContent = tl.isHour ? shortTime(tl.h, tl.m) : '';
    grid.appendChild(label);

    STATE.days.forEach((dk, di) => {
      const daySlots = STATE.dayMap[dk].slots;
      const slot = daySlots[ti];
      const count = slot ? slot.available.size : 0;
      const heatClass = `h${Math.min(count, 10)}`;

      const cell = document.createElement('div');
      cell.className = `cell ${heatClass}`;
      cell.dataset.di = di;
      cell.dataset.ti = ti;
      cell.dataset.dayKey = dk;
      if (slot) {
        cell.dataset.h = slot.h;
        cell.dataset.m = slot.m;
        cell.dataset.people = JSON.stringify([...slot.available]);
        cell.dataset.time = slot.label;
        cell.dataset.day = STATE.dayNames[di];
        cell.dataset.count = count;
        cell.dataset.slotKey = `${dk}:${slot.h}:${slot.m}`;
      }

      // Blocked?
      if (slot && STATE.blocked.has(`${dk}:${slot.h}:${slot.m}`)) {
        cell.classList.add('blocked');
      }

      cell.addEventListener('mouseenter', ttShow);
      cell.addEventListener('mouseleave', ttHide);
      cell.addEventListener('click', onCellClick);

      grid.appendChild(cell);
      cellEls.push(cell);
    });
  });
}

function renderLegend() {
  const el = document.getElementById('legend');
  const max = Math.min(STATE.numPeople, 10);
  let html = '<span>0</span>';
  for (let i = 0; i <= max; i++) {
    const colors = ['#111827','#1e1a2e','#2d1f3d','#4c1d6e','#7c2d8e','#b83a6a','#e04842','#f59e0b','#fbbf24','#fcd34d','#fde68a'];
    html += `<div class="hswatch" style="background:${colors[i] || colors[colors.length-1]}"></div>`;
  }
  html += `<span>${STATE.numPeople}/${STATE.numPeople}</span>`;
  el.innerHTML = html;
}

function renderPeople() {
  const list = document.getElementById('peopleList');
  list.innerHTML = '';
  const maxH = Math.max(...STATE.names.map(n => getTotalHours(n)));

  // Sort by total hours desc
  const sorted = [...STATE.names].sort((a,b) => getTotalHours(b) - getTotalHours(a));

  sorted.forEach((name, i) => {
    const h = getTotalHours(name);
    const row = document.createElement('div');
    row.className = 'person-row' + (STATE.required.has(name) ? ' required' : '');
    row.dataset.person = name;
    row.style.position = 'relative';

    row.addEventListener('click', () => toggleFilter(name));
    row.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      toggleRequired(name);
    });

    row.innerHTML = `
      <div class="pdot" style="background:${pcolor(name)};color:${pcolor(name)}"></div>
      <div class="pname">${shortName(name)}</div>
      <div class="phours">${h.toFixed(0)}h</div>
      <div class="pbar-track"><div class="pbar-fill" style="width:${(h/maxH)*100}%;background:${pcolor(name)};animation-delay:${.2+i*.06}s;opacity:0" onanimationstart="this.style.opacity=1"></div></div>
    `;
    list.appendChild(row);
  });
}

function getTotalHours(name) {
  let count = 0;
  for (const slot of STATE.slots) {
    if (slot.available.has(name)) count++;
  }
  return count * 0.25;
}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  DECISION VIEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
function updateSolutions() {
  STATE.currentResults = solve();
  renderDecisions();
  if (STATE.heatmapOpen) drawSolutionOutlines();
}

function renderDecisions() {
  const container = document.getElementById('decisions');
  container.innerHTML = '';
  const r = STATE.currentResults;
  if (!r) return;

  const usePairs = r.numMeetings === 2 && r.pairs.length > 0;
  const sortedNames = [...STATE.names].sort((a,b) => getTotalHours(b) - getTotalHours(a));

  // --- Single meeting options ---
  const singles = r.single.filter(w => !STATE.dismissed.has(w.key));
  if (singles.length > 0) {
    const best = singles[0];
    const label = best.count === STATE.numPeople ? 'Best Times â€” Everyone Available' : 'Best Times';
    container.insertAdjacentHTML('beforeend', `<div class="section-head">${label}</div>`);
    const grid = document.createElement('div');
    grid.className = 'options-grid';
    singles.forEach((win, rank) => {
      const card = document.createElement('div');
      card.className = 'option-card' + (rank === 0 ? ' best' : '');
      card.style.animationDelay = `${rank * 0.06}s`;
      let dots = '';
      for (const name of sortedNames) {
        const here = win.attendees.has(name);
        const c = pcolor(name);
        dots += here
          ? `<div class="att-dot present" style="background:${c}" title="${shortName(name)}"></div>`
          : `<div class="att-dot absent" style="box-shadow:inset 0 0 0 1.5px ${c}" title="${shortName(name)} â€” absent"></div>`;
      }
      const miss = [...win.missing].map(shortName).join(', ');
      card.innerHTML = `
        ${rank === 0 ? '<div class="card-badge">Top pick</div>' : ''}
        <div class="card-day">${win.dayName}</div>
        <div class="card-time">${formatTime(win.startH,win.startM)} â€“ ${formatTime(win.endH,win.endM)}</div>
        <div class="att-dots">${dots}</div>
        <div class="card-count">${win.count} of ${STATE.numPeople}</div>
        ${win.missing.size > 0
          ? `<div class="card-missing">without ${miss}</div>`
          : '<div class="card-missing card-all">everyone</div>'}
        <button class="card-dismiss" onclick="dismissOption('${win.key}')">Not this one</button>`;
      grid.appendChild(card);
    });
    container.appendChild(grid);
  }

  // --- Full coverage plans (pairs) ---
  if (usePairs) {
    const plans = r.pairs.filter(p => !STATE.dismissed.has(p.key));
    if (plans.length > 0) {
      container.insertAdjacentHTML('beforeend', `<div class="section-head">Full Coverage Plans</div>`);
      plans.forEach((plan, rank) => {
        const card = document.createElement('div');
        card.className = 'plan-card' + (rank === 0 ? ' best' : '');
        card.style.animationDelay = `${rank * 0.08}s`;

        function dots(win) {
          let h = '';
          for (const name of sortedNames) {
            const here = win.attendees.has(name);
            const c = pcolor(name);
            h += here
              ? `<div class="att-dot present" style="background:${c}" title="${shortName(name)}"></div>`
              : `<div class="att-dot absent" style="box-shadow:inset 0 0 0 1.5px ${c}" title="${shortName(name)}"></div>`;
          }
          return h;
        }

        const onlyA = [...plan.a.attendees].filter(n => !plan.b.attendees.has(n));
        const onlyB = [...plan.b.attendees].filter(n => !plan.a.attendees.has(n));
        const both = [...plan.a.attendees].filter(n => plan.b.attendees.has(n));
        let bd = '<div class="plan-breakdown">';
        if (both.length) bd += `<span>${both.map(shortName).join(', ')}</span> at both<br>`;
        if (onlyA.length) bd += `<span>${onlyA.map(shortName).join(', ')}</span> only ${plan.a.dayName}<br>`;
        if (onlyB.length) bd += `<span>${onlyB.map(shortName).join(', ')}</span> only ${plan.b.dayName}`;
        if (plan.uncovered.length) bd += `<br>Missing: ${plan.uncovered.map(shortName).join(', ')}`;
        bd += '</div>';

        card.innerHTML = `
          <div class="plan-header">
            <div class="plan-label">${rank === 0 ? 'Best plan' : 'Plan ' + String.fromCharCode(65 + rank)}</div>
            <div class="plan-coverage-badge">${plan.coverage}/${STATE.numPeople} covered</div>
          </div>
          <button class="plan-dismiss" onclick="dismissOption('${plan.key}')" title="Dismiss">&times;</button>
          <div class="plan-meetings">
            <div class="plan-meeting">
              <div class="card-day">${plan.a.dayName}</div>
              <div class="card-time">${formatTime(plan.a.startH,plan.a.startM)} â€“ ${formatTime(plan.a.endH,plan.a.endM)}</div>
              <div class="att-dots">${dots(plan.a)}</div>
              <div class="card-count">${plan.a.count}/${STATE.numPeople}</div>
            </div>
            <div class="plan-connector">+</div>
            <div class="plan-meeting">
              <div class="card-day">${plan.b.dayName}</div>
              <div class="card-time">${formatTime(plan.b.startH,plan.b.startM)} â€“ ${formatTime(plan.b.endH,plan.b.endM)}</div>
              <div class="att-dots">${dots(plan.b)}</div>
              <div class="card-count">${plan.b.count}/${STATE.numPeople}</div>
            </div>
          </div>
          ${bd}`;
        container.appendChild(card);
      });
    }
  }

  // --- Insights ---
  renderInsights(container);

  // --- Dismissed info ---
  if (STATE.dismissed.size > 0) {
    container.insertAdjacentHTML('beforeend',
      `<div class="dismissed-info">${STATE.dismissed.size} dismissed Â· <a onclick="resetDismissed()">show all</a></div>`);
  }

  if (singles.length === 0 && (!usePairs || r.pairs.filter(p => !STATE.dismissed.has(p.key)).length === 0)) {
    if (STATE.dismissed.size > 0) {
      container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);font-size:.75rem">All options dismissed.<br><a onclick="resetDismissed()" style="color:var(--accent);cursor:pointer">Show all</a></div>';
    } else {
      container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);font-size:.75rem">No valid windows found. Try adjusting constraints.</div>';
    }
  }
}

function renderInsights(container) {
  const insights = computeInsights();
  if (insights.length === 0) return;
  const panel = document.createElement('div');
  panel.className = 'insights-panel';
  let html = '<div class="section-head" style="margin-top:0;margin-bottom:.4rem">Scheduling Insights</div>';
  insights.forEach(ins => {
    html += `<div class="insight-item"><span class="insight-icon">${ins.icon}</span><span>${ins.text}</span></div>`;
  });
  panel.innerHTML = html;
  container.appendChild(panel);
}

function computeInsights() {
  const insights = [];
  const names = STATE.names;
  const slots = STATE.slots;
  const N = names.length;
  if (N === 0 || slots.length === 0) return insights;

  // --- Precompute per-person data ---
  const hours = names.map(n => ({ name: n, h: getTotalHours(n) }));
  hours.sort((a,b) => a.h - b.h);
  const least = hours[0], most = hours[hours.length - 1];

  // Per-person per-day hours and earliest/latest times
  const personDayH = {};   // name â†’ { dayKey â†’ hours }
  const personEarliest = {};  // name â†’ earliest hour (decimal)
  const personLatest = {};    // name â†’ latest hour (decimal)
  for (const n of names) {
    personDayH[n] = {};
    personEarliest[n] = 24;
    personLatest[n] = 0;
  }
  for (const s of slots) {
    const t = s.h + s.m / 60;
    for (const n of s.available) {
      personDayH[n][s.dayKey] = (personDayH[n][s.dayKey] || 0) + 0.25;
      if (t < personEarliest[n]) personEarliest[n] = t;
      if (t + 0.25 > personLatest[n]) personLatest[n] = t + 0.25;
    }
  }

  // Pairwise overlap matrix
  const overlap = {};
  for (let i = 0; i < N; i++) {
    for (let j = i + 1; j < N; j++) {
      let c = 0;
      for (const s of slots) {
        if (s.available.has(names[i]) && s.available.has(names[j])) c++;
      }
      overlap[`${i}:${j}`] = c;
    }
  }

  // --- 1. Early Bird / Night Owl ---
  let earliestPerson = names[0], latestPerson = names[0];
  for (const n of names) {
    if (personEarliest[n] < personEarliest[earliestPerson]) earliestPerson = n;
    if (personLatest[n] > personLatest[latestPerson]) latestPerson = n;
  }
  if (earliestPerson !== latestPerson) {
    const eTime = formatTime(Math.floor(personEarliest[earliestPerson]), Math.round((personEarliest[earliestPerson] % 1) * 60));
    const lH = personLatest[latestPerson];
    const lTime = formatTime(Math.floor(lH), Math.round((lH % 1) * 60));
    insights.push({ icon: 'ğŸŒ…', text: `<strong>${shortName(earliestPerson)}</strong> is the early bird (from ${eTime}) â€” <strong>${shortName(latestPerson)}</strong> is the night owl (until ${lTime})` });
  }

  // --- 2. Morning vs Afternoon team ---
  // Normalize by number of slots in each period so 9am-4pm doesn't auto-skew afternoon
  let mAvail = 0, mPossible = 0, aAvail = 0, aPossible = 0;
  for (const s of slots) {
    if (s.h < 12) { mAvail += s.available.size; mPossible += N; }
    else { aAvail += s.available.size; aPossible += N; }
  }
  if (mPossible > 0 && aPossible > 0) {
    const mRate = Math.round(mAvail / mPossible * 100);
    const aRate = Math.round(aAvail / aPossible * 100);
    const diff = Math.abs(mRate - aRate);
    if (diff > 15) {
      const skew = mRate > aRate ? 'mornings' : 'afternoons';
      const pct = Math.max(mRate, aRate);
      insights.push({ icon: skew === 'mornings' ? 'â˜€ï¸' : 'ğŸŒ™', text: `The team skews toward <strong>${skew}</strong> â€” ${pct}% fill rate ${skew === 'mornings' ? 'before noon' : 'after noon'} vs ${Math.min(mRate,aRate)}% ${skew === 'mornings' ? 'after' : 'before'}` });
    }
  }

  // --- Helper: display hours/minutes nicely ---
  function fmtHrs(slots) {
    const h = slots * 0.25;
    if (h === 0) return 'never';
    if (h < 1) return `${Math.round(h * 60)}min`;
    return `${h % 1 === 0 ? h : h.toFixed(1)}h`;
  }

  // --- 3. Best Buds (most overlap pair) ---
  let maxOv = 0, bestPair = null;
  let minOv = Infinity, hardPair = null;
  for (let i = 0; i < N; i++) {
    for (let j = i + 1; j < N; j++) {
      const c = overlap[`${i}:${j}`];
      if (c > maxOv) { maxOv = c; bestPair = [names[i], names[j]]; }
      if (c < minOv) { minOv = c; hardPair = [names[i], names[j]]; }
    }
  }
  if (bestPair && maxOv > 0) {
    insights.push({ icon: 'ğŸ¤', text: `<strong>Best buds:</strong> ${shortName(bestPair[0])} + ${shortName(bestPair[1])} overlap <span class="hl">${fmtHrs(maxOv)}</span> â€” easiest pair to co-schedule` });
  }

  // --- 4. Ships in the Night (hardest pair) ---
  if (hardPair && minOv * 0.25 <= 4) {
    insights.push({ icon: 'ğŸš¢', text: `<strong>Ships in the night:</strong> ${shortName(hardPair[0])} + ${shortName(hardPair[1])} overlap only <span class="warn">${fmtHrs(minOv)}</span> â€” hardest to get in a room together` });
  }

  // --- 5. Unanimous Windows ---
  // Group contiguous unanimous slots into windows so Mon 9:00-10:30 = 1 window, not 6 "slots"
  if (N >= 3) {
    const unanBlocks = [];
    for (const dk of STATE.days) {
      const daySlots = STATE.dayMap[dk].slots;
      let blockStart = null, blockLen = 0;
      for (let i = 0; i < daySlots.length; i++) {
        if (daySlots[i].available.size === N) {
          if (blockStart === null) blockStart = i;
          blockLen++;
        } else {
          if (blockStart !== null) {
            unanBlocks.push({ dayKey: dk, dayName: STATE.dayNames[STATE.days.indexOf(dk)], start: daySlots[blockStart], len: blockLen });
            blockStart = null; blockLen = 0;
          }
        }
      }
      if (blockStart !== null) {
        unanBlocks.push({ dayKey: dk, dayName: STATE.dayNames[STATE.days.indexOf(dk)], start: daySlots[blockStart], len: blockLen });
      }
    }
    if (unanBlocks.length === 0) {
      insights.push({ icon: 'ğŸ¯', text: `<span class="warn">Zero</span> unanimous windows â€” no contiguous block works for everyone` });
    } else {
      const descs = unanBlocks.map(b => {
        const dur = (b.len * 0.25);
        const durStr = dur >= 1 ? `${dur}h` : `${dur * 60}min`;
        return `${b.dayName} ${shortTime(b.start.h, b.start.m)} (${durStr})`;
      });
      const label = unanBlocks.length === 1 ? '1 unanimous window' : `${unanBlocks.length} unanimous windows`;
      insights.push({ icon: 'ğŸ¯', text: `<span class="hl">${label}</span> where the whole team is free: ${descs.join(', ')}` });
    }
  }

  // --- 6. The Linchpin ---
  // Who, if removed, opens the most new full-attendance windows?
  // Deduplicate overlapping windows so we count distinct time blocks, not 15-min shifts
  const r = STATE.currentResults;
  if (r && r.single.length > 0) {
    const bestCount = r.single[0].count;
    if (bestCount < N) {
      const allWindows = r.windows || r.single;
      let bestGain = 0, linchpin = null;
      for (const n of names) {
        // Collect windows that become full if this person is dropped
        const full = allWindows.filter(w => {
          const ct = w.attendees.has(n) ? w.count - 1 : w.count;
          return ct >= N - 1;
        });
        // Deduplicate overlapping windows
        const deduped = [];
        for (const w of full) {
          if (!deduped.some(d => windowsOverlap(d, w))) deduped.push(w);
        }
        if (deduped.length > bestGain) { bestGain = deduped.length; linchpin = n; }
      }
      if (linchpin && bestGain > 0) {
        insights.push({ icon: 'ğŸ”‘', text: `<strong>The linchpin:</strong> ${shortName(linchpin)} â€” dropping them as required would unlock <span class="hl">${bestGain}</span> perfect-attendance ${bestGain === 1 ? 'window' : 'windows'}` });
      }
    }
  }

  // --- 7. Ghost Day ---
  const dayTotals = {};
  for (const dk of STATE.days) {
    dayTotals[dk] = 0;
    for (const s of STATE.dayMap[dk].slots) {
      dayTotals[dk] += s.available.size;
    }
  }
  const dayEntries = Object.entries(dayTotals);
  if (dayEntries.length > 1) {
    dayEntries.sort((a,b) => a[1] - b[1]);
    const [worstDk, worstCount] = dayEntries[0];
    const [bestDk, bestCount] = dayEntries[dayEntries.length - 1];
    const dropPct = Math.round((1 - worstCount / bestCount) * 100);
    if (dropPct > 25) {
      const worstName = STATE.dayNames[STATE.days.indexOf(worstDk)];
      const bestName = STATE.dayNames[STATE.days.indexOf(bestDk)];
      insights.push({ icon: 'ğŸ‘»', text: `<strong>Ghost day:</strong> ${worstName} has ${dropPct}% less availability than ${bestName}` });
    }
  }

  // --- 8. The Minimalist / The Accommodator ---
  if (least.h > 0 && least.h < most.h * 0.5 && N >= 4) {
    insights.push({ icon: 'ğŸ“', text: `<strong>${shortName(least.name)}</strong> offered ${fmtHrs(Math.round(least.h / 0.25))} â€” <strong>${shortName(most.name)}</strong> offered ${fmtHrs(Math.round(most.h / 0.25))} <span class="soft">(${(most.h / least.h).toFixed(1)}Ã— more)</span>` });
  }

  // --- 9. "If only..." nudge ---
  if (STATE.currentResults && STATE.currentResults.suggestion) {
    insights.push({ icon: 'ğŸ’¡', text: STATE.currentResults.suggestion });
  }

  // --- 10. Lunch Hour Crunch ---
  let lunchAvail = 0, lunchSlots = 0;
  for (const s of slots) {
    if (s.h >= 12 && s.h < 13) {
      lunchSlots++;
      lunchAvail += s.available.size;
    }
  }
  if (lunchSlots > 0) {
    const lunchPct = Math.round(lunchAvail / (lunchSlots * N) * 100);
    if (lunchPct < 50) {
      insights.push({ icon: 'ğŸ½ï¸', text: `Only <span class="warn">${lunchPct}%</span> of the team is free over lunch (12â€“1 PM) â€” slim pickings for a midday meeting` });
    }
  }

  return insights;
}

function renderTeamBar() {
  const bar = document.getElementById('teamBar');
  if (!bar) return;
  bar.innerHTML = '';
  const sorted = [...STATE.names].sort((a,b) => getTotalHours(b) - getTotalHours(a));
  const allH = sorted.map(n => getTotalHours(n));
  const avgH = allH.reduce((a,b) => a+b, 0) / allH.length;
  const minH = Math.min(...allH), maxH = Math.max(...allH);

  bar.insertAdjacentHTML('beforeend', '<span class="team-label">Team</span>');
  sorted.forEach(name => {
    const h = getTotalHours(name);
    const isReq = STATE.required.has(name);
    const chip = document.createElement('span');
    chip.className = 'team-chip' + (isReq ? ' required' : '');
    chip.dataset.person = name;
    chip.title = isReq ? 'Click to un-require' : 'Click to require in all meetings';
    chip.onclick = () => { toggleRequired(name); renderTeamBar(); };
    chip.innerHTML = `<span class="chip-dot" style="background:${pcolor(name)}"></span>
      <span>${shortName(name)}</span><span class="chip-hours">${h.toFixed(0)}h</span>
      ${isReq ? '<span class="chip-req">req</span>' : ''}`;
    bar.appendChild(chip);
  });
  bar.insertAdjacentHTML('beforeend',
    `<span class="team-stats">avg ${avgH.toFixed(0)}h Â· range ${minH.toFixed(0)}&ndash;${maxH.toFixed(0)}h</span>`);
}

function dismissOption(key) {
  STATE.dismissed.add(key);
  renderDecisions();
  if (STATE.heatmapOpen) drawSolutionOutlines();
}

function resetDismissed() {
  STATE.dismissed.clear();
  renderDecisions();
  if (STATE.heatmapOpen) drawSolutionOutlines();
}

function toggleHeatmap() {
  STATE.heatmapOpen = !STATE.heatmapOpen;
  const sec = document.getElementById('heatmapSection');
  const tog = document.getElementById('heatmapToggle');
  if (STATE.heatmapOpen) {
    sec.classList.remove('collapsed');
    tog.innerHTML = '&#9662; Raw availability';
    if (!sec.dataset.rendered) {
      renderGrid();
      renderLegend();
      renderPeople();
      sec.dataset.rendered = 'true';
    }
    drawSolutionOutlines();
  } else {
    sec.classList.add('collapsed');
    tog.innerHTML = '&#9656; Explore raw availability';
  }
}

function drawSolutionOutlines() {
  document.querySelectorAll('.sol-outline').forEach(e => e.remove());
  if (!STATE.currentResults) return;
  const r = STATE.currentResults;
  const usePairs = r.numMeetings === 2 && r.pairs.length > 0;
  if (usePairs && r.pairs.length > 0) {
    const best = r.pairs.filter(p => !STATE.dismissed.has(p.key))[0];
    if (best) { drawOutline(best.a, 'A'); drawOutline(best.b, 'B'); }
  } else if (r.single.length > 0) {
    const best = r.single.filter(w => !STATE.dismissed.has(w.key))[0];
    if (best) drawOutline(best, 'BEST');
  }
}

function drawOutline(win, label) {
  const grid = document.getElementById('grid');
  const di = STATE.days.indexOf(win.dayKey);
  const ti = STATE.timeLabels.findIndex(t => t.h === win.startH && t.m === win.startM);
  const dur = parseInt(document.getElementById('ctrlDuration').querySelector('.seg-btn.active').dataset.val);
  const tiEnd = ti + dur - 1;

  const firstCell = grid.querySelector(`.cell[data-di="${di}"][data-ti="${ti}"]`);
  const lastCell = grid.querySelector(`.cell[data-di="${di}"][data-ti="${tiEnd}"]`);
  if (!firstCell || !lastCell) return;

  const gridRect = grid.getBoundingClientRect();
  const fRect = firstCell.getBoundingClientRect();
  const lRect = lastCell.getBoundingClientRect();

  const outline = document.createElement('div');
  outline.className = 'sol-outline';
  outline.style.left = (fRect.left - gridRect.left - 2) + 'px';
  outline.style.top = (fRect.top - gridRect.top - 2) + 'px';
  outline.style.width = (fRect.width + 4) + 'px';
  outline.style.height = (lRect.bottom - fRect.top + 4) + 'px';

  const tag = document.createElement('div');
  tag.className = 'sol-tag';
  tag.textContent = label;
  outline.appendChild(tag);

  grid.style.position = 'relative';
  grid.appendChild(outline);
}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  INTERACTIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
function ttShow(e) {
  const cell = e.currentTarget;
  if (!cell.dataset.people) return;
  const tt = document.getElementById('tooltip');
  const people = JSON.parse(cell.dataset.people);
  const count = parseInt(cell.dataset.count);
  const allNames = STATE.names;

  document.getElementById('ttTime').textContent = `${cell.dataset.day} Â· ${cell.dataset.time}`;
  document.getElementById('ttCount').textContent = `${count}/${STATE.numPeople} available`;

  const chipsEl = document.getElementById('ttChips');
  chipsEl.innerHTML = '';
  people.forEach(n => {
    const chip = document.createElement('span');
    chip.className = 'tt-chip';
    chip.textContent = shortName(n);
    chip.style.background = pcolor(n) + '33';
    chip.style.color = pcolor(n);
    chipsEl.appendChild(chip);
  });

  const absent = allNames.filter(n => !people.includes(n));
  document.getElementById('ttAbsent').textContent = absent.length ? `Missing: ${absent.map(shortName).join(', ')}` : '';

  const isBlocked = cell.classList.contains('blocked');
  document.getElementById('ttBlockHint').textContent = isBlocked ? 'â— BLOCKED â€” click to unblock' : 'Shift+click to block this slot';

  tt.classList.add('vis');
  const r = cell.getBoundingClientRect();
  let left = r.right + 10, top = r.top - 10;
  if (left + 240 > window.innerWidth) left = r.left - 250;
  if (top + 120 > window.innerHeight) top = window.innerHeight - 130;
  if (top < 8) top = 8;
  tt.style.left = left + 'px';
  tt.style.top = top + 'px';
}

function ttHide() {
  document.getElementById('tooltip').classList.remove('vis');
}

function onCellClick(e) {
  const cell = e.currentTarget;
  if (!cell.dataset.slotKey) return;
  // Shift+click or regular click to toggle block
  const key = cell.dataset.slotKey;
  if (e.shiftKey || (!STATE.activePerson && e.button === 0)) {
    // Only block on shift+click to avoid confusion with person filter
    if (e.shiftKey) {
      if (STATE.blocked.has(key)) {
        STATE.blocked.delete(key);
        cell.classList.remove('blocked');
      } else {
        STATE.blocked.add(key);
        cell.classList.add('blocked');
      }
      renderBlockedList();
      updateSolutions();
    }
  }
}

function renderBlockedList() {
  const el = document.getElementById('blockedList');
  if (STATE.blocked.size === 0) {
    el.innerHTML = '<span style="font-size:.6rem;color:var(--text-muted)">Shift+click cells below</span>';
    return;
  }
  el.innerHTML = '';
  for (const key of STATE.blocked) {
    const [dk, h, m] = key.split(':');
    const di = STATE.days.indexOf(dk);
    const dayName = STATE.dayNames[di] || dk;
    const chip = document.createElement('span');
    chip.className = 'blocked-chip';
    chip.innerHTML = `${dayName} ${shortTime(+h,+m)} <span class="x">Ã—</span>`;
    chip.onclick = () => {
      STATE.blocked.delete(key);
      const cell = document.querySelector(`.cell[data-slot-key="${key}"]`);
      if (cell) cell.classList.remove('blocked');
      renderBlockedList();
      updateSolutions();
    };
    el.appendChild(chip);
  }
}

function toggleFilter(name) {
  if (STATE.activePerson === name) {
    clearFilter();
    return;
  }
  STATE.activePerson = name;
  document.querySelectorAll('.person-row').forEach(r => r.classList.toggle('active', r.dataset.person === name));
  document.getElementById('clearBtn').classList.add('show');

  cellEls.forEach(cell => {
    if (!cell.dataset.people) return;
    const people = JSON.parse(cell.dataset.people);
    if (people.includes(name)) {
      cell.classList.add('person-on');
      cell.classList.remove('person-off');
      cell.style.background = pcolor(name);
    } else {
      cell.classList.remove('person-on');
      cell.classList.add('person-off');
    }
  });
}

function clearFilter() {
  STATE.activePerson = null;
  document.querySelectorAll('.person-row').forEach(r => r.classList.remove('active'));
  document.getElementById('clearBtn').classList.remove('show');
  cellEls.forEach(cell => {
    cell.classList.remove('person-on', 'person-off');
    cell.style.background = '';
  });
}

function toggleRequired(name) {
  if (STATE.required.has(name)) {
    STATE.required.delete(name);
  } else {
    STATE.required.add(name);
  }
  document.querySelectorAll('.person-row').forEach(r => {
    r.classList.toggle('required', STATE.required.has(r.dataset.person));
  });
  updateSolutions();
}

function onConstraintChange() {
  updateSolutions();
}

// Segmented button click handlers
document.querySelectorAll('.seg-btns').forEach(group => {
  group.querySelectorAll('.seg-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      group.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      onConstraintChange();
    });
  });
});

function goHome() {
  location.hash = '';
  document.getElementById('solver').classList.remove('active');
  document.getElementById('landing').classList.remove('hidden');
}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  INIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
function init() {
  setupBookmarklet();

  const raw = decodeHash();
  if (raw) {
    launchSolver(raw);
  }

  window.addEventListener('hashchange', () => {
    const raw = decodeHash();
    if (raw) launchSolver(raw);
  });

  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      if (document.getElementById('solver').classList.contains('active')) updateSolutions();
    }, 150);
  });
}

function launchSolver(raw) {
  processData(raw);
  document.getElementById('landing').classList.add('hidden');
  document.getElementById('solver').classList.add('active');
  document.getElementById('participantBadge').textContent = `${STATE.numPeople} participants`;
  document.getElementById('eventInfo').textContent = `${STATE.days.length} days Â· ${STATE.timeLabels.length} time slots`;

  renderTeamBar();
  updateSolutions();
}

/*â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  DEMO DATA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
function loadDemo() {
  // Generate demo data matching our writing meeting When2Meet
  const names = ["Alex","Blake","Casey","Dana","Ellis","Farid","Grace","Harper"];
  const ids = [1,2,3,4,5,6,7,8];
  const baseTs = 279795600; // Monday 9:00 UTC (When2Meet epoch)
  const times = [];
  const available = [];

  // Define availability per person per day
  const avail = {
    "Monday": {
      "9:00-10:15": [1,2,3,4,5,6,7,8],
      "10:30-10:45": [1,2,3,4,5,7,8],
      "11:00-11:45": [1,2,3,5,7,8],
      "12:00-15:45": [1,2,3,5,7]
    },
    "Tuesday": {
      "9:00-9:45": [3,4,5,6,7],
      "10:00-10:45": [4,5,6,7],
      "11:00-11:45": [4,5,6],
      "12:00-12:45": [3,4,5,6],
      "13:00-13:30": [3,4,5,6,8],
      "13:45-13:45": [3,4,5,6,7,8],
      "14:00-14:15": [2,3,4,6,7,8],
      "14:30-14:45": [2,4,7,8],
      "15:00-15:45": [2,7,8]
    },
    "Wednesday": {
      "9:00-9:45": [2,4,5,6,7,8],
      "10:00-10:45": [2,4,5,7,8],
      "11:00-11:45": [2,5,7,8],
      "12:00-13:45": [5,6,7,8],
      "14:00-14:45": [2,5,6,8],
      "15:00-15:45": [2,4,5,6]
    },
    "Thursday": {
      "9:00-10:00": [3,4,5,6],
      "10:15-10:45": [1,3,4,5,6],
      "11:00-13:45": [1,5,6],
      "14:00-14:15": [1,2,6],
      "14:30-14:45": [1,2,3],
      "15:00-15:45": [1,2,3,4]
    },
    "Friday": {
      "9:00-9:00": [2,4,5,6,7,8],
      "9:15-10:45": [2,4,5,6,7],
      "11:00-11:45": [2,4,6],
      "12:00-12:45": [4,6],
      "13:00-15:45": []
    }
  };

  const dayOffsets = [0, 86400, 86400*2, 86400*3, 86400*4]; // Mon-Fri
  const dayKeys = ["Monday","Tuesday","Wednesday","Thursday","Friday"];

  dayKeys.forEach((day, di) => {
    for (let h = 9; h <= 15; h++) {
      for (let m = 0; m < 60; m += 15) {
        if (h === 15 && m > 45) break;
        const ts = baseTs + dayOffsets[di] + (h - 9) * 3600 + m * 60;
        times.push(ts);
        // Find who's available
        const slot = `${h}:${String(m).padStart(2,'0')}`;
        let ppl = [];
        for (const [range, ids_list] of Object.entries(avail[day])) {
          if (isInRange(h, m, range)) { ppl = ids_list; break; }
        }
        available.push(ppl);
      }
    }
  });

  const data = { n: names, i: ids, a: available, t: times };
  const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(data))));
  location.hash = encoded;
}

function isInRange(h, m, range) {
  const parts = range.split('-');
  const parseT = (s) => { const [hh,mm] = s.split(':'); return parseInt(hh)*60+parseInt(mm); };
  const t = h * 60 + m;
  if (parts.length === 1) {
    return t === parseT(parts[0]);
  }
  return t >= parseT(parts[0]) && t <= parseT(parts[1]);
}

init();
</script>
</body>
</html>
